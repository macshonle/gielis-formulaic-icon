<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Superformula Icon Maker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            margin-bottom: 24px;
            font-size: 28px;
            font-weight: 600;
            text-align: center;
        }

        .main-workspace {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .export-panel {
            width: 280px;
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .export-panel h2 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .export-preview {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 16px;
        }

        .preview-box {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .preview-box img {
            border: 1px solid #444;
            border-radius: 4px;
            background: white;
        }

        .preview-box span {
            font-size: 11px;
            color: #888;
        }

        .download-links {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .download-link {
            color: #007aff;
            text-decoration: none;
            font-size: 13px;
            padding: 6px 0;
            transition: color 0.15s;
            cursor: pointer;
        }

        .download-link:hover {
            color: #0051d5;
            text-decoration: underline;
        }

        .import-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: stretch;
        }

        .import-button {
            background: #4a4a4a;
            color: #fff;
            border: 1px solid #5a5a5a;
            border-radius: 6px;
            padding: 10px 16px;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .import-button:hover {
            background: #5a5a5a;
        }

        .import-info {
            font-size: 11px;
            color: #888;
            margin: 0;
            text-align: center;
        }

        .panel-divider {
            height: 1px;
            background: #3a3a3a;
            margin: 20px 0;
        }

        .canvas-container {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        #mainCanvas {
            display: block;
            border: 1px solid #444;
            background: white;
            cursor: crosshair;
            border-radius: 4px;
        }

        .layers-panel {
            width: 200px;
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .layers-panel h2 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .shape-list {
            max-height: 320px;
            overflow-y: auto;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 4px;
            margin-bottom: 12px;
        }

        .shape-item {
            padding: 8px;
            margin-bottom: 4px;
            background: #2a2a2a;
            border-radius: 4px;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.15s;
            font-size: 12px;
        }

        .shape-item:hover {
            background: #333;
        }

        .shape-item.selected {
            background: #007aff;
        }

        .shape-item.dragging {
            opacity: 0.5;
        }

        .shape-item-info {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
        }

        .shape-item-preview {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid #666;
            flex-shrink: 0;
        }

        .shape-item-label {
            font-size: 11px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .delete-btn {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            padding: 0;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            transition: all 0.15s;
            font-size: 14px;
            line-height: 1;
        }

        .delete-btn:hover {
            background: #ff3b30;
            color: white;
        }

        .layer-actions {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .layer-actions button {
            flex: 1;
            padding: 6px;
            font-size: 11px;
            background: #1a1a1a;
            border: 1px solid #444;
            color: #b0b0b0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .layer-actions button:hover {
            background: #333;
            border-color: #666;
        }

        .demos-panel {
            width: 200px;
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .demos-panel h2 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .demo-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .demo-item {
            padding: 12px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
            font-size: 13px;
            text-align: center;
        }

        .demo-item:hover {
            background: #333;
            border-color: #007aff;
            transform: translateY(-1px);
        }

        .demo-item:active {
            transform: translateY(0);
        }

        .demo-item.random {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            color: white;
            font-weight: 600;
        }

        .demo-item.random:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
            border-color: #764ba2;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .control-panel {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .control-panel h2 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        fieldset {
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 0;
        }

        legend {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 0 8px;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(28px, 1fr));
            gap: 6px;
            margin-bottom: 12px;
        }

        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.selected {
            border-color: #fff;
            box-shadow: 0 0 0 2px #2a2a2a, 0 0 0 4px #fff;
        }

        .input-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .input-row label {
            font-size: 12px;
            font-weight: 500;
            color: #b0b0b0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
            min-width: 80px;
        }

        .input-row input,
        .input-row select {
            flex: 1;
        }

        .input-row .range-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input-row .range-value {
            font-size: 12px;
            color: #888;
            min-width: 40px;
            text-align: right;
        }

        input[type="number"],
        input[type="text"],
        input[type="range"],
        select {
            background: #1a1a1a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 13px;
        }

        input[type="number"]:focus,
        input[type="text"]:focus,
        select:focus {
            outline: none;
            border-color: #007aff;
        }

        input[type="range"] {
            padding: 0;
            height: 6px;
            border-radius: 3px;
            cursor: pointer;
        }

        input[type="color"] {
            width: 40px;
            height: 32px;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: pointer;
            background: none;
            padding: 2px;
        }

        .color-input-group {
            display: flex;
            gap: 8px;
            align-items: center;
            flex: 1;
        }

        .color-input-group input[type="text"] {
            flex: 1;
        }

        .param-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        button.primary {
            width: 100%;
            background: #007aff;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.15s;
        }

        button.primary:hover {
            background: #0051d5;
        }

        button.primary:active {
            transform: scale(0.98);
        }

        .no-fill-indicator {
            width: 32px;
            height: 32px;
            background: white;
            border: 1px solid #444;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            transition: all 0.15s;
        }

        .no-fill-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            background: #ff3b30;
            transform: translateY(-50%) rotate(-45deg);
        }

        .no-fill-indicator:hover {
            border-color: #007aff;
        }

        .fill-control {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .fill-control input[type="color"] {
            flex: 0 0 40px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Superformula Icon Maker</h1>

        <div class="main-workspace">
            <!-- Export/Import Panel -->
            <div class="export-panel">
                <h2>Import</h2>
                <div class="import-section">
                    <input type="file" id="importJSON" accept=".json" style="display: none;">
                    <button id="importJSONBtn" class="import-button">Load from JSON</button>
                    <p class="import-info">Load previously saved layers</p>
                </div>

                <div class="panel-divider"></div>

                <h2>Export</h2>
                <div class="export-preview">
                    <div class="preview-box">
                        <img id="applePreview" width="32" height="32">
                        <span>180×180</span>
                    </div>
                    <div class="preview-box">
                        <img id="faviconPreview" width="24" height="24">
                        <span>32×32</span>
                    </div>
                    <div class="preview-box">
                        <img id="faviconPreview16" width="16" height="16">
                        <span>16×16</span>
                    </div>
                </div>
                <div class="download-links">
                    <a class="download-link" id="exportAppleIcon">Download apple-touch-icon.png</a>
                    <a class="download-link" id="exportFavicon">Download favicon.ico</a>
                    <a class="download-link" id="exportJSON">Save as JSON</a>
                </div>
            </div>

            <!-- Canvas -->
            <div class="canvas-container">
                <canvas id="mainCanvas" width="384" height="384"></canvas>
            </div>

            <!-- Layers Panel -->
            <div class="layers-panel">
                <h2>Layers</h2>
                <div class="shape-list" id="shapeList"></div>
                <div class="layer-actions">
                    <button id="addShape">+ Add</button>
                    <button id="clearAll">Clear</button>
                </div>
            </div>

            <!-- Demos Panel -->
            <div class="demos-panel">
                <h2>Demos</h2>
                <div class="demo-list" id="demoList"></div>
            </div>
        </div>

        <!-- Controls Grid -->
        <div class="controls-grid">
            <!-- Colors Panel -->
            <div class="control-panel">
                <h2>Colors</h2>
                <div class="color-palette" id="colorPalette"></div>
                <div class="input-row">
                    <label>Fill</label>
                    <div class="fill-control">
                        <div class="no-fill-indicator" id="noFillBtn" style="display: none;"></div>
                        <input type="color" id="fillColorPicker">
                        <input type="text" id="customColor" placeholder="#ff5733">
                    </div>
                </div>
                <div class="input-row">
                    <label>Opacity</label>
                    <div class="range-container">
                        <input type="range" id="opacity" min="0" max="1" step="0.01" value="1">
                        <span class="range-value" id="opacityValue">1.00</span>
                    </div>
                </div>
                <div class="input-row">
                    <label>Stroke</label>
                    <select id="strokeWidth">
                        <option value="0">None</option>
                        <option value="1">1px</option>
                        <option value="2">2px</option>
                        <option value="3">3px</option>
                        <option value="4" selected>4px</option>
                        <option value="6">6px</option>
                        <option value="8">8px</option>
                        <option value="10">10px</option>
                        <option value="15">15px</option>
                        <option value="20">20px</option>
                    </select>
                </div>
                <div class="input-row" id="strokeColorRow">
                    <label>Stroke Color</label>
                    <div class="color-input-group">
                        <input type="color" id="strokeColorPicker" value="#000000">
                        <input type="text" id="strokeColor" placeholder="#000000" value="#000000">
                    </div>
                </div>
            </div>

            <!-- Shape Parameters Panel -->
            <div class="control-panel">
                <fieldset>
                    <legend>Shape Parameters</legend>
                    <div class="input-row">
                        <label>Preset</label>
                        <select id="presetSelect">
                            <option value="">Custom</option>
                            <option value="circle">Perfect Circle</option>
                            <option value="square">Rounded Square</option>
                            <option value="squircle">Icon Squircle</option>
                            <option value="star4">4-Pointed Star</option>
                            <option value="star5">5-Pointed Star</option>
                            <option value="star8">8-Pointed Star</option>
                            <option value="flower">Flower Shape</option>
                            <option value="gear">Gear/Cog</option>
                            <option value="diamond">Diamond</option>
                            <option value="cross">Cross/Plus</option>
                        </select>
                    </div>
                    <div class="input-row">
                        <label>m (symmetry)</label>
                        <input type="number" id="paramM" min="0" max="20" step="0.1" value="5">
                    </div>
                    <div class="param-grid">
                        <div class="input-row">
                            <label>n1</label>
                            <input type="number" id="paramN1" min="0.1" max="10" step="0.1" value="0.5">
                        </div>
                        <div class="input-row">
                            <label>n2</label>
                            <input type="number" id="paramN2" min="0.1" max="10" step="0.1" value="0.5">
                        </div>
                        <div class="input-row">
                            <label>n3</label>
                            <input type="number" id="paramN3" min="0.1" max="10" step="0.1" value="0.5">
                        </div>
                        <div class="input-row">
                            <label>a</label>
                            <input type="number" id="paramA" min="0.1" max="5" step="0.1" value="1">
                        </div>
                        <div class="input-row">
                            <label>b</label>
                            <input type="number" id="paramB" min="0.1" max="5" step="0.1" value="1">
                        </div>
                    </div>
                </fieldset>
            </div>

            <!-- Transform Panel -->
            <div class="control-panel">
                <h2>Transform</h2>
                <div class="input-row">
                    <label>Size</label>
                    <div class="range-container">
                        <input type="range" id="size" min="10" max="300" value="150">
                        <span class="range-value" id="sizeValue">150</span>
                    </div>
                </div>
                <div class="input-row">
                    <label>Rotation</label>
                    <div class="range-container">
                        <input type="range" id="rotation" min="0" max="360" value="0">
                        <span class="range-value" id="rotationValue">0°</span>
                    </div>
                </div>
                <div class="input-row">
                    <label>Position X</label>
                    <input type="number" id="posX" min="0" max="384" value="192">
                </div>
                <div class="input-row">
                    <label>Position Y</label>
                    <input type="number" id="posY" min="0" max="384" value="192">
                </div>
            </div>
        </div>
    </div>

    <script>
        // Modern icon color palette
        const defaultPalette = [
            '#FF6B6B', '#FF8E53', '#FFA64D', '#FFD93D', '#6BCF7F', '#4ECDC4',
            '#45B7D1', '#4D96FF', '#6C5CE7', '#A78BFA', '#F472B6', '#FB7185',
            '#EF4444', '#F97316', '#F59E0B', '#EAB308', '#22C55E', '#14B8A6',
            '#06B6D4', '#3B82F6', '#6366F1', '#8B5CF6', '#EC4899', '#F43F5E',
            '#DC2626', '#EA580C', '#D97706', '#CA8A04', '#16A34A', '#0D9488',
            '#0891B2', '#2563EB', '#4F46E5', '#7C3AED', '#DB2777', '#E11D48',
            '#000000', '#374151', '#6B7280', '#9CA3AF', '#D1D5DB', '#FFFFFF'
        ];

        // Preset configurations
        const presets = {
            circle: { m: 4, n1: 2, n2: 2, n3: 2, a: 1, b: 1 },
            square: { m: 4, n1: 4, n2: 4, n3: 4, a: 1, b: 1 },
            squircle: { m: 4, n1: 2, n2: 5, n3: 5, a: 1, b: 1 },
            star4: { m: 4, n1: 0.5, n2: 0.5, n3: 0.5, a: 1, b: 1 },
            star5: { m: 5, n1: 0.5, n2: 0.5, n3: 0.5, a: 1, b: 1 },
            star8: { m: 8, n1: 0.5, n2: 0.5, n3: 0.5, a: 1, b: 1 },
            flower: { m: 6, n1: 1, n2: 4, n3: 4, a: 1, b: 1 },
            gear: { m: 8, n1: 10, n2: 10, n3: 10, a: 1, b: 1 },
            diamond: { m: 4, n1: 1, n2: 1, n3: 1, a: 1, b: 1 },
            cross: { m: 4, n1: 100, n2: 100, n3: 100, a: 1, b: 1 }
        };

        // Helper function to lighten a color
        function lightenColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // Demo configurations
        const demos = {
            descendingStar: {
                name: "Descending Star",
                shapes: (function() {
                    const shapes = [];
                    const colors = ['#FF6B6B', '#FF8E53', '#FFA64D', '#FFD93D', '#6BCF7F', '#4ECDC4',
                                  '#45B7D1', '#4D96FF', '#6C5CE7', '#A78BFA', '#F472B6', '#FB7185',
                                  '#EF4444', '#F97316', '#F59E0B'];
                    for (let i = 0; i < 15; i++) {
                        const points = 18 - i;
                        const size = 160 - (i * 8);
                        const rotation = (i * 8) * Math.PI / 180;
                        const opacity = 0.9 - (i * 0.03);
                        const baseColor = colors[i % colors.length];
                        const lightColor = lightenColor(baseColor, i * 3);

                        const hexToRgba = (hex, alpha) => {
                            const r = parseInt(hex.slice(1, 3), 16);
                            const g = parseInt(hex.slice(3, 5), 16);
                            const b = parseInt(hex.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        };

                        shapes.push({
                            cx: 192,
                            cy: 192,
                            radius: size,
                            rotation: rotation,
                            m: points,
                            n1: 0.5,
                            n2: 0.5,
                            n3: 0.5,
                            a: 1,
                            b: 1,
                            fillColor: hexToRgba(lightColor, opacity),
                            strokeColor: lightenColor(baseColor, i * 2),
                            strokeWidth: 2
                        });
                    }
                    return shapes;
                })()
            },
            bloomingFlower: {
                name: "Blooming Flower",
                shapes: (function() {
                    const shapes = [];
                    const petalCounts = [3, 4, 5, 6, 7, 8, 9, 10];
                    const colors = ['#F472B6', '#EC4899', '#DB2777', '#BE185D', '#9F1239', '#881337', '#701A47', '#5D1A57'];

                    petalCounts.forEach((petals, i) => {
                        const size = 50 + (i * 15);
                        const rotation = (i * 15) * Math.PI / 180;
                        const opacity = 0.5 + (i * 0.06);

                        const hexToRgba = (hex, alpha) => {
                            const r = parseInt(hex.slice(1, 3), 16);
                            const g = parseInt(hex.slice(3, 5), 16);
                            const b = parseInt(hex.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        };

                        shapes.push({
                            cx: 192,
                            cy: 192,
                            radius: size,
                            rotation: rotation,
                            m: petals,
                            n1: 1,
                            n2: 4,
                            n3: 4,
                            a: 1,
                            b: 1,
                            fillColor: hexToRgba(colors[i], opacity),
                            strokeColor: colors[i],
                            strokeWidth: 1
                        });
                    });

                    return shapes;
                })()
            },
            clockworkGears: {
                name: "Clockwork Gears",
                shapes: (function() {
                    const shapes = [];
                    const gearConfigs = [
                        { teeth: 12, size: 140, color: '#6B7280', rotation: 0 },
                        { teeth: 10, size: 110, color: '#9CA3AF', rotation: 18 },
                        { teeth: 8, size: 85, color: '#D1D5DB', rotation: 22.5 },
                        { teeth: 6, size: 60, color: '#E5E7EB', rotation: 30 },
                    ];

                    gearConfigs.forEach((config, i) => {
                        const hexToRgba = (hex, alpha) => {
                            const r = parseInt(hex.slice(1, 3), 16);
                            const g = parseInt(hex.slice(3, 5), 16);
                            const b = parseInt(hex.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        };

                        shapes.push({
                            cx: 192,
                            cy: 192,
                            radius: config.size,
                            rotation: config.rotation * Math.PI / 180,
                            m: config.teeth,
                            n1: 10,
                            n2: 10,
                            n3: 10,
                            a: 1,
                            b: 1,
                            fillColor: hexToRgba(config.color, 0.7),
                            strokeColor: '#374151',
                            strokeWidth: 3
                        });
                    });

                    return shapes;
                })()
            },
            rainbowBurst: {
                name: "Rainbow Burst",
                shapes: (function() {
                    const shapes = [];
                    const colors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];

                    colors.forEach((color, i) => {
                        const size = 150 - (i * 15);
                        const rotation = (i * 25) * Math.PI / 180;
                        const opacity = 0.6;

                        const hexToRgba = (hex, alpha) => {
                            const r = parseInt(hex.slice(1, 3), 16);
                            const g = parseInt(hex.slice(3, 5), 16);
                            const b = parseInt(hex.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        };

                        shapes.push({
                            cx: 192,
                            cy: 192,
                            radius: size,
                            rotation: rotation,
                            m: 12,
                            n1: 0.5,
                            n2: 0.5,
                            n3: 0.5,
                            a: 1,
                            b: 1,
                            fillColor: hexToRgba(color, opacity),
                            strokeColor: color,
                            strokeWidth: 2
                        });
                    });

                    return shapes;
                })()
            },
            geometricMandala: {
                name: "Geometric Mandala",
                shapes: (function() {
                    const shapes = [];
                    const layers = [
                        { m: 8, n1: 0.5, n2: 0.5, n3: 0.5, size: 150, color: '#6366F1', rotation: 0 },
                        { m: 8, n1: 2, n2: 2, n3: 2, size: 120, color: '#8B5CF6', rotation: 22.5 },
                        { m: 8, n1: 4, n2: 4, n3: 4, size: 90, color: '#A78BFA', rotation: 0 },
                        { m: 12, n1: 1, n2: 4, n3: 4, size: 65, color: '#C4B5FD', rotation: 15 },
                        { m: 4, n1: 2, n2: 5, n3: 5, size: 40, color: '#DDD6FE', rotation: 0 },
                    ];

                    layers.forEach((layer, i) => {
                        const hexToRgba = (hex, alpha) => {
                            const r = parseInt(hex.slice(1, 3), 16);
                            const g = parseInt(hex.slice(3, 5), 16);
                            const b = parseInt(hex.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        };

                        shapes.push({
                            cx: 192,
                            cy: 192,
                            radius: layer.size,
                            rotation: layer.rotation * Math.PI / 180,
                            m: layer.m,
                            n1: layer.n1,
                            n2: layer.n2,
                            n3: layer.n3,
                            a: 1,
                            b: 1,
                            fillColor: hexToRgba(layer.color, 0.7),
                            strokeColor: layer.color,
                            strokeWidth: 2
                        });
                    });

                    return shapes;
                })()
            }
        };

        // Application state
        let shapes = [];
        let selectedShapeIndex = null;
        let currentColor = '#FF6B6B';
        let currentOpacity = 1;
        let currentStrokeColor = '#000000';
        let draggedItem = null;

        // Canvas setup
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // Initialize color palette
        function initColorPalette() {
            const palette = document.getElementById('colorPalette');
            defaultPalette.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.background = color;
                if (color === currentColor) {
                    swatch.classList.add('selected');
                }
                swatch.addEventListener('click', () => {
                    currentColor = color;
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');
                    document.getElementById('customColor').value = color;
                    document.getElementById('fillColorPicker').value = color.startsWith('#') ? color : '#FF6B6B';
                    updateSelectedShape();
                });
                palette.appendChild(swatch);
            });
        }

        // Superformula calculation
        function superformulaR(theta, {m, n1, n2, n3, a = 1, b = 1}) {
            const t1 = Math.pow(Math.abs(Math.cos((m * theta) / 4) / a), n2);
            const t2 = Math.pow(Math.abs(Math.sin((m * theta) / 4) / b), n3);
            const denom = t1 + t2;
            return Math.pow(Math.max(denom, 1e-12), -1 / n1);
        }

        // Draw superformula shape
        function drawSuperformula(ctx, shape, scaleFactor = 1) {
            const {cx, cy, radius, rotation, m, n1, n2, n3, a, b, steps = 1500} = shape;

            ctx.beginPath();

            for (let i = 0; i <= steps; i++) {
                const theta = (i / steps) * 2 * Math.PI;
                const r = superformulaR(theta, {m, n1, n2, n3, a, b});
                const ang = theta + rotation;
                const x = (cx * scaleFactor) + (radius * scaleFactor * r * Math.cos(ang));
                const y = (cy * scaleFactor) + (radius * scaleFactor * r * Math.sin(ang));

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.closePath();
        }

        // Render a shape with its properties
        function renderShape(ctx, shape, scaleFactor = 1) {
            ctx.save();

            drawSuperformula(ctx, shape, scaleFactor);

            const hasFill = shape.fillColor && shape.fillColor !== 'none';
            const hasStroke = shape.strokeWidth > 0;

            if (hasFill) {
                ctx.fillStyle = shape.fillColor;
                ctx.fill();
            }

            if (hasStroke) {
                ctx.strokeStyle = shape.strokeColor;
                ctx.lineWidth = shape.strokeWidth * scaleFactor;
                ctx.stroke();
            }

            ctx.restore();
        }

        // Render all shapes to canvas
        function renderCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            shapes.forEach(shape => {
                renderShape(ctx, shape);
            });

            updateExportPreviews();
        }

        // Create shape object from current settings
        function createShapeFromSettings() {
            const opacity = parseFloat(document.getElementById('opacity').value);
            const hexToRgba = (hex, alpha) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            };

            let fillColor = currentColor;
            if (currentColor.startsWith('#') && currentColor.length === 7) {
                fillColor = hexToRgba(currentColor, opacity);
            } else if (currentColor.startsWith('rgb(')) {
                fillColor = currentColor.replace('rgb', 'rgba').replace(')', `, ${opacity})`);
            }

            return {
                cx: parseFloat(document.getElementById('posX').value),
                cy: parseFloat(document.getElementById('posY').value),
                radius: parseFloat(document.getElementById('size').value),
                rotation: parseFloat(document.getElementById('rotation').value) * Math.PI / 180,
                m: parseFloat(document.getElementById('paramM').value),
                n1: parseFloat(document.getElementById('paramN1').value),
                n2: parseFloat(document.getElementById('paramN2').value),
                n3: parseFloat(document.getElementById('paramN3').value),
                a: parseFloat(document.getElementById('paramA').value),
                b: parseFloat(document.getElementById('paramB').value),
                fillColor: fillColor,
                strokeColor: document.getElementById('strokeColor').value || currentStrokeColor,
                strokeWidth: parseFloat(document.getElementById('strokeWidth').value),
            };
        }

        // Add new shape
        function addShape() {
            const shape = createShapeFromSettings();
            shapes.push(shape);
            selectedShapeIndex = shapes.length - 1;
            updateShapeList();
            renderCanvas();
        }

        // Update selected shape with current settings
        function updateSelectedShape() {
            if (selectedShapeIndex !== null && shapes[selectedShapeIndex]) {
                shapes[selectedShapeIndex] = createShapeFromSettings();
                updateShapeList();
                renderCanvas();
            }
        }

        // Load shape into editor
        function loadShapeToEditor(shape) {
            document.getElementById('posX').value = shape.cx;
            document.getElementById('posY').value = shape.cy;
            document.getElementById('size').value = shape.radius;
            document.getElementById('sizeValue').textContent = shape.radius;

            const rotationDeg = shape.rotation * 180 / Math.PI;
            document.getElementById('rotation').value = rotationDeg;
            document.getElementById('rotationValue').textContent = rotationDeg.toFixed(0) + '°';

            document.getElementById('paramM').value = shape.m;
            document.getElementById('paramN1').value = shape.n1;
            document.getElementById('paramN2').value = shape.n2;
            document.getElementById('paramN3').value = shape.n3;
            document.getElementById('paramA').value = shape.a;
            document.getElementById('paramB').value = shape.b;

            // Load fill color and opacity
            const rgbaMatch = shape.fillColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (rgbaMatch) {
                const r = parseInt(rgbaMatch[1]);
                const g = parseInt(rgbaMatch[2]);
                const b = parseInt(rgbaMatch[3]);
                const opacity = rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1;

                // Convert to hex
                const hexColor = '#' + [r, g, b].map(x => {
                    const hex = x.toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');

                // Update global state
                currentColor = hexColor;
                currentOpacity = opacity;

                // Update color inputs
                document.getElementById('fillColorPicker').value = hexColor;
                document.getElementById('customColor').value = hexColor;

                // Update opacity input
                document.getElementById('opacity').value = opacity;

                // Update color palette selection
                document.querySelectorAll('.color-swatch').forEach(swatch => {
                    if (swatch.style.background === hexColor || swatch.style.background === `rgb(${r}, ${g}, ${b})`) {
                        swatch.classList.add('selected');
                    } else {
                        swatch.classList.remove('selected');
                    }
                });
            }

            document.getElementById('strokeWidth').value = shape.strokeWidth;
            document.getElementById('strokeColor').value = shape.strokeColor;
            document.getElementById('strokeColorPicker').value = shape.strokeColor;

            updateStrokeColorVisibility();
        }

        // Update shape list UI
        function updateShapeList() {
            const list = document.getElementById('shapeList');
            list.innerHTML = '';

            shapes.forEach((shape, index) => {
                const item = document.createElement('div');
                item.className = 'shape-item';
                item.draggable = true;
                if (index === selectedShapeIndex) {
                    item.classList.add('selected');
                }

                const info = document.createElement('div');
                info.className = 'shape-item-info';

                const preview = document.createElement('div');
                preview.className = 'shape-item-preview';
                preview.style.background = shape.fillColor;

                const label = document.createElement('span');
                label.className = 'shape-item-label';
                label.textContent = `Shape ${index + 1}`;

                info.appendChild(preview);
                info.appendChild(label);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.textContent = '×';
                deleteBtn.title = 'Delete shape';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteShape(index);
                });

                item.appendChild(info);
                item.appendChild(deleteBtn);

                // Drag and drop handlers
                item.addEventListener('dragstart', (e) => {
                    draggedItem = index;
                    item.classList.add('dragging');
                });

                item.addEventListener('dragend', (e) => {
                    item.classList.remove('dragging');
                    draggedItem = null;
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });

                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggedItem !== null && draggedItem !== index) {
                        const temp = shapes[draggedItem];
                        shapes.splice(draggedItem, 1);
                        shapes.splice(index, 0, temp);

                        if (selectedShapeIndex === draggedItem) {
                            selectedShapeIndex = index;
                        } else if (selectedShapeIndex === index) {
                            selectedShapeIndex = draggedItem > index ? selectedShapeIndex + 1 : selectedShapeIndex - 1;
                        }

                        updateShapeList();
                        renderCanvas();
                    }
                });

                item.addEventListener('click', () => {
                    selectedShapeIndex = index;
                    loadShapeToEditor(shape);
                    updateShapeList();
                });

                list.appendChild(item);
            });
        }

        // Delete shape at index
        function deleteShape(index) {
            shapes.splice(index, 1);
            if (selectedShapeIndex === index) {
                selectedShapeIndex = shapes.length > 0 ? Math.max(0, index - 1) : null;
                if (selectedShapeIndex !== null && shapes[selectedShapeIndex]) {
                    loadShapeToEditor(shapes[selectedShapeIndex]);
                }
            } else if (selectedShapeIndex > index) {
                selectedShapeIndex--;
            }
            updateShapeList();
            renderCanvas();
        }

        // Clear all shapes
        function clearAll() {
            if (confirm('Clear all shapes?')) {
                shapes = [];
                selectedShapeIndex = null;
                updateShapeList();
                renderCanvas();
            }
        }

        // Load a demo
        function loadDemo(demoKey) {
            if (demos[demoKey]) {
                shapes = JSON.parse(JSON.stringify(demos[demoKey].shapes)); // Deep clone
                selectedShapeIndex = shapes.length > 0 ? shapes.length - 1 : null;
                if (selectedShapeIndex !== null) {
                    loadShapeToEditor(shapes[selectedShapeIndex]);
                }
                updateShapeList();
                renderCanvas();
            }
        }

        // Generate random demo
        function generateRandomDemo() {
            shapes = [];
            const layerCount = Math.floor(Math.random() * 6) + 3; // 3-8 layers

            for (let i = 0; i < layerCount; i++) {
                const m = Math.floor(Math.random() * 16) + 3; // 3-18 symmetry
                const n1 = Math.random() * 9 + 0.5; // 0.5-9.5
                const n2 = Math.random() * 9 + 0.5;
                const n3 = Math.random() * 9 + 0.5;
                const a = Math.random() * 2 + 0.5; // 0.5-2.5
                const b = Math.random() * 2 + 0.5;
                const size = Math.random() * 120 + 40; // 40-160
                const rotation = Math.random() * 360 * Math.PI / 180;
                const opacity = Math.random() * 0.5 + 0.4; // 0.4-0.9

                // Random color from palette
                const color = defaultPalette[Math.floor(Math.random() * (defaultPalette.length - 6))]; // Exclude greys

                const hexToRgba = (hex, alpha) => {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                };

                shapes.push({
                    cx: 192,
                    cy: 192,
                    radius: size,
                    rotation: rotation,
                    m: m,
                    n1: n1,
                    n2: n2,
                    n3: n3,
                    a: a,
                    b: b,
                    fillColor: hexToRgba(color, opacity),
                    strokeColor: color,
                    strokeWidth: Math.random() > 0.5 ? Math.floor(Math.random() * 3) + 1 : 0
                });
            }

            selectedShapeIndex = shapes.length > 0 ? shapes.length - 1 : null;
            if (selectedShapeIndex !== null) {
                loadShapeToEditor(shapes[selectedShapeIndex]);
            }
            updateShapeList();
            renderCanvas();
        }

        // Initialize demo list
        function initDemoList() {
            const demoList = document.getElementById('demoList');

            // Add preset demos
            Object.keys(demos).forEach(key => {
                const demo = demos[key];
                const item = document.createElement('div');
                item.className = 'demo-item';
                item.textContent = demo.name;
                item.addEventListener('click', () => loadDemo(key));
                demoList.appendChild(item);
            });

            // Add random button
            const randomItem = document.createElement('div');
            randomItem.className = 'demo-item random';
            randomItem.textContent = 'Random';
            randomItem.addEventListener('click', generateRandomDemo);
            demoList.appendChild(randomItem);
        }

        // Update stroke color field visibility
        function updateStrokeColorVisibility() {
            const strokeWidth = parseFloat(document.getElementById('strokeWidth').value);
            const strokeColorRow = document.getElementById('strokeColorRow');
            const strokeColorInput = document.getElementById('strokeColor');
            const strokeColorPicker = document.getElementById('strokeColorPicker');
            const isStrokeEnabled = strokeWidth > 0;

            // Disable/enable inputs instead of hiding
            strokeColorInput.disabled = !isStrokeEnabled;
            strokeColorPicker.disabled = !isStrokeEnabled;

            // Adjust opacity to indicate disabled state
            strokeColorRow.style.opacity = isStrokeEnabled ? '1' : '0.5';
            strokeColorRow.style.pointerEvents = isStrokeEnabled ? 'auto' : 'none';
        }

        // Apply preset
        function applyPreset(presetName) {
            if (presets[presetName]) {
                const preset = presets[presetName];
                document.getElementById('paramM').value = preset.m;
                document.getElementById('paramN1').value = preset.n1;
                document.getElementById('paramN2').value = preset.n2;
                document.getElementById('paramN3').value = preset.n3;
                document.getElementById('paramA').value = preset.a;
                document.getElementById('paramB').value = preset.b;
                updateSelectedShape();
            }
        }

        // Render to a specific size canvas
        function renderToCanvas(size) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = size;
            tempCanvas.height = size;
            const tempCtx = tempCanvas.getContext('2d');

            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, size, size);

            const scaleFactor = size / 384;

            shapes.forEach(shape => {
                renderShape(tempCtx, shape, scaleFactor);
            });

            return tempCanvas;
        }

        // Update export previews
        function updateExportPreviews() {
            const preview180 = renderToCanvas(180);
            const preview32 = renderToCanvas(32);
            const preview16 = renderToCanvas(16);

            document.getElementById('applePreview').src = preview180.toDataURL('image/png');
            document.getElementById('faviconPreview').src = preview32.toDataURL('image/png');
            document.getElementById('faviconPreview16').src = preview16.toDataURL('image/png');
        }

        // Export apple touch icon
        function exportAppleTouchIcon() {
            const iconCanvas = renderToCanvas(180);
            iconCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'apple-touch-icon.png';
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        // Create ICO file with multiple sizes
        function createIcoFile(sizes) {
            const images = sizes.map(size => {
                const canvas = renderToCanvas(size);
                return {
                    size: size,
                    canvas: canvas,
                    imageData: canvas.getContext('2d').getImageData(0, 0, size, size)
                };
            });

            let offset = 6 + (images.length * 16);
            const imageBuffers = images.map(img => createBMPData(img.imageData));

            const totalSize = offset + imageBuffers.reduce((sum, buf) => sum + buf.byteLength, 0);
            const buffer = new ArrayBuffer(totalSize);
            const view = new DataView(buffer);
            const uint8View = new Uint8Array(buffer);

            view.setUint16(0, 0, true);
            view.setUint16(2, 1, true);
            view.setUint16(4, images.length, true);

            let currentOffset = offset;
            images.forEach((img, i) => {
                const entryOffset = 6 + (i * 16);
                const imageSize = imageBuffers[i].byteLength;

                view.setUint8(entryOffset, img.size === 256 ? 0 : img.size);
                view.setUint8(entryOffset + 1, img.size === 256 ? 0 : img.size);
                view.setUint8(entryOffset + 2, 0);
                view.setUint8(entryOffset + 3, 0);
                view.setUint16(entryOffset + 4, 1, true);
                view.setUint16(entryOffset + 6, 32, true);
                view.setUint32(entryOffset + 8, imageSize, true);
                view.setUint32(entryOffset + 12, currentOffset, true);

                currentOffset += imageSize;
            });

            currentOffset = offset;
            imageBuffers.forEach(imgBuffer => {
                uint8View.set(new Uint8Array(imgBuffer), currentOffset);
                currentOffset += imgBuffer.byteLength;
            });

            return buffer;
        }

        // Create BMP data for ICO format
        function createBMPData(imageData) {
            if (!imageData || !imageData.width || !imageData.height) {
                return new ArrayBuffer(0);
            }

            const width = imageData.width;
            const height = imageData.height;
            const headerSize = 40;
            const imageSize = width * height * 4;

            const maskRowSize = Math.ceil(Math.ceil(width / 8) / 4) * 4;
            const maskSize = maskRowSize * height;
            const totalSize = headerSize + imageSize + maskSize;

            const buffer = new ArrayBuffer(totalSize);
            const view = new DataView(buffer);
            const uint8View = new Uint8Array(buffer);

            view.setUint32(0, headerSize, true);
            view.setInt32(4, width, true);
            view.setInt32(8, height * 2, true);
            view.setUint16(12, 1, true);
            view.setUint16(14, 32, true);
            view.setUint32(16, 0, true);
            view.setUint32(20, imageSize + maskSize, true);
            view.setInt32(24, 0, true);
            view.setInt32(28, 0, true);
            view.setUint32(32, 0, true);
            view.setUint32(36, 0, true);

            let offset = headerSize;
            for (let y = height - 1; y >= 0; y--) {
                for (let x = 0; x < width; x++) {
                    const srcOffset = (y * width + x) * 4;
                    uint8View[offset++] = imageData.data[srcOffset + 2];
                    uint8View[offset++] = imageData.data[srcOffset + 1];
                    uint8View[offset++] = imageData.data[srcOffset];
                    uint8View[offset++] = imageData.data[srcOffset + 3];
                }
            }

            for (let y = height - 1; y >= 0; y--) {
                for (let x = 0; x < maskRowSize; x++) {
                    uint8View[offset++] = 0;
                }
            }

            return buffer;
        }

        // Export favicon
        function exportFavicon() {
            const sizes = [16, 32, 48, 64, 128, 256];
            const icoData = createIcoFile(sizes);
            const blob = new Blob([icoData], { type: 'image/x-icon' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'favicon.ico';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Export as JSON
        function exportJSON() {
            const data = {
                version: "1.0",
                shapes: shapes
            };
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'icon-layers.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Import from JSON
        function importJSON(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.shapes && Array.isArray(data.shapes)) {
                        shapes = data.shapes;
                        selectedShapeIndex = null;
                        updateShapeList();
                        renderCanvas();
                        updateExportPreviews();
                    } else {
                        alert('Invalid JSON file format. Expected a "shapes" array.');
                    }
                } catch (error) {
                    alert('Error parsing JSON file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Event listeners
        document.getElementById('addShape').addEventListener('click', addShape);
        document.getElementById('clearAll').addEventListener('click', clearAll);
        document.getElementById('exportAppleIcon').addEventListener('click', exportAppleTouchIcon);
        document.getElementById('exportFavicon').addEventListener('click', exportFavicon);
        document.getElementById('exportJSON').addEventListener('click', exportJSON);

        // Import JSON
        document.getElementById('importJSONBtn').addEventListener('click', () => {
            document.getElementById('importJSON').click();
        });
        document.getElementById('importJSON').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                importJSON(file);
            }
            e.target.value = ''; // Reset input so same file can be loaded again
        });

        // Preset selector
        document.getElementById('presetSelect').addEventListener('change', (e) => {
            applyPreset(e.target.value);
        });

        // Custom color input
        document.getElementById('customColor').addEventListener('input', (e) => {
            currentColor = e.target.value;
            document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
            if (e.target.value.startsWith('#')) {
                document.getElementById('fillColorPicker').value = e.target.value;
            }
            updateSelectedShape();
        });

        document.getElementById('fillColorPicker').addEventListener('input', (e) => {
            currentColor = e.target.value;
            document.getElementById('customColor').value = currentColor;
            document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
            updateSelectedShape();
        });

        // Stroke color inputs
        document.getElementById('strokeColor').addEventListener('input', (e) => {
            currentStrokeColor = e.target.value;
            if (e.target.value.startsWith('#')) {
                document.getElementById('strokeColorPicker').value = e.target.value;
            }
            updateSelectedShape();
        });

        document.getElementById('strokeColorPicker').addEventListener('input', (e) => {
            currentStrokeColor = e.target.value;
            document.getElementById('strokeColor').value = e.target.value;
            updateSelectedShape();
        });

        // Stroke width
        document.getElementById('strokeWidth').addEventListener('change', (e) => {
            updateStrokeColorVisibility();
            updateSelectedShape();
        });

        // Opacity slider
        document.getElementById('opacity').addEventListener('input', (e) => {
            currentOpacity = parseFloat(e.target.value);
            document.getElementById('opacityValue').textContent = currentOpacity.toFixed(2);
            updateSelectedShape();
        });

        // Size and rotation sliders
        document.getElementById('size').addEventListener('input', (e) => {
            document.getElementById('sizeValue').textContent = e.target.value;
            updateSelectedShape();
        });

        document.getElementById('rotation').addEventListener('input', (e) => {
            document.getElementById('rotationValue').textContent = e.target.value + '°';
            updateSelectedShape();
        });

        // All number inputs update on change
        ['paramM', 'paramN1', 'paramN2', 'paramN3', 'paramA', 'paramB',
         'posX', 'posY'].forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                document.getElementById('presetSelect').value = '';
                updateSelectedShape();
            });
        });

        // Initialize
        initColorPalette();
        initDemoList();
        updateStrokeColorVisibility();
        renderCanvas();
    </script>
</body>
</html>
