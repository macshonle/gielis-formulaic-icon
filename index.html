<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Superformula Icon Maker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            margin-bottom: 24px;
            font-size: 28px;
            font-weight: 600;
            text-align: center;
        }

        .main-workspace {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .export-panel {
            width: 280px;
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .export-panel h2 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .export-preview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 12px;
            margin-bottom: 16px;
        }

        .preview-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .preview-box img,
        .preview-box > div {
            border: 1px solid #444;
            border-radius: 4px;
            background: white;
        }

        .preview-box span {
            font-size: 10px;
            color: #888;
            text-align: center;
        }

        .download-links {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        .download-link {
            color: #007aff;
            text-decoration: none;
            font-size: 13px;
            padding: 4px 0;
            transition: color 0.15s;
            cursor: pointer;
        }

        .download-link:hover {
            color: #0051d5;
            text-decoration: underline;
        }

        .import-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: stretch;
        }

        .import-button {
            background: #4a4a4a;
            color: #fff;
            border: 1px solid #5a5a5a;
            border-radius: 6px;
            padding: 10px 16px;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .import-button:hover {
            background: #5a5a5a;
        }

        .import-info {
            font-size: 11px;
            color: #888;
            margin: 0;
            text-align: center;
        }

        .panel-divider {
            height: 1px;
            background: #3a3a3a;
            margin: 20px 0;
        }

        .canvas-container {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        #mainCanvas {
            display: block;
            border: 1px solid #444;
            background: white;
            cursor: crosshair;
            border-radius: 4px;
        }

        .layers-panel {
            width: 200px;
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .layers-panel h2 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .shape-list {
            max-height: 320px;
            overflow-y: auto;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 4px;
            margin-bottom: 12px;
        }

        .shape-item {
            padding: 8px;
            margin-bottom: 4px;
            background: #2a2a2a;
            border-radius: 4px;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.15s;
            font-size: 12px;
        }

        .shape-item:hover {
            background: #333;
        }

        .shape-item.selected {
            background: #007aff;
        }

        .shape-item.dragging {
            opacity: 0.5;
        }

        .shape-item-info {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
        }

        .shape-item-preview {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid #666;
            flex-shrink: 0;
        }

        .shape-item-label {
            font-size: 11px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .delete-btn {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            padding: 0;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            transition: all 0.15s;
            font-size: 14px;
            line-height: 1;
        }

        .delete-btn:hover {
            background: #ff3b30;
            color: white;
        }

        .layer-actions {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .layer-actions button {
            flex: 1;
            padding: 6px;
            font-size: 11px;
            background: #1a1a1a;
            border: 1px solid #444;
            color: #b0b0b0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .layer-actions button:hover {
            background: #333;
            border-color: #666;
        }

        .demos-panel {
            width: 200px;
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .demos-panel h2 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .demo-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .demo-item {
            padding: 12px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
            font-size: 13px;
            text-align: center;
        }

        .demo-item:hover {
            background: #333;
            border-color: #007aff;
            transform: translateY(-1px);
        }

        .demo-item:active {
            transform: translateY(0);
        }

        .demo-item.random {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            color: white;
            font-weight: 600;
        }

        .demo-item.random:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
            border-color: #764ba2;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .control-panel {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .control-panel h2 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        fieldset {
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 0;
        }

        legend {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 0 8px;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(28px, 1fr));
            gap: 6px;
            margin-bottom: 12px;
        }

        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.selected {
            border-color: #fff;
            box-shadow: 0 0 0 2px #2a2a2a, 0 0 0 4px #fff;
        }

        .input-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .input-row label {
            font-size: 12px;
            font-weight: 500;
            color: #b0b0b0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
            min-width: 1.5em;
        }

        .input-row input,
        .input-row select {
            flex: 1;
        }

        .input-row .range-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input-row .range-value {
            font-size: 12px;
            color: #888;
            min-width: 40px;
            text-align: right;
        }

        input[type="number"],
        input[type="text"],
        input[type="range"],
        select {
            background: #1a1a1a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 13px;
        }

        input[type="number"] {
            max-width: 7em;
        }

        input[type="number"]:focus,
        input[type="text"]:focus,
        select:focus {
            outline: none;
            border-color: #007aff;
        }

        input[type="range"] {
            padding: 0;
            height: 6px;
            border-radius: 3px;
            cursor: pointer;
        }

        input[type="color"] {
            width: 40px;
            height: 32px;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: pointer;
            background: none;
            padding: 2px;
        }

        .color-input-group {
            display: flex;
            gap: 8px;
            align-items: center;
            flex: 1;
        }

        .color-input-group input[type="text"] {
            flex: 1;
        }

        .param-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .param-grid-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
        }

        .position-inputs {
            display: flex;
            gap: 8px;
            flex: 1;
        }

        .position-inputs input {
            flex: 1;
        }

        button.primary {
            width: 100%;
            background: #007aff;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.15s;
        }

        button.primary:hover {
            background: #0051d5;
        }

        button.primary:active {
            transform: scale(0.98);
        }

        .no-fill-indicator {
            width: 32px;
            height: 32px;
            background: white;
            border: 2px solid #444;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            transition: all 0.15s;
            flex-shrink: 0;
        }

        .no-fill-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            background: #ff3b30;
            transform: translateY(-50%) rotate(-45deg);
        }

        .no-fill-indicator:hover {
            border-color: #007aff;
        }

        .no-fill-indicator.active {
            border-color: #007aff;
            border-width: 3px;
            box-shadow: 0 0 0 1px #007aff;
        }

        .fill-control {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .fill-control input[type="color"] {
            flex: 0 0 40px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Superformula Icon Maker</h1>

        <div class="main-workspace">
            <!-- Export/Import Panel -->
            <div class="export-panel">
                <h2>Import</h2>
                <div class="import-section">
                    <input type="file" id="importJSON" accept=".json" style="display: none;">
                    <button id="importJSONBtn" class="import-button">Load from JSON</button>
                    <p class="import-info">Load previously saved layers</p>
                </div>

                <div class="panel-divider"></div>

                <h2>Export</h2>
                <div class="export-preview">
                    <div class="preview-box">
                        <img id="preview64" width="64" height="64">
                        <span>64×64</span>
                    </div>
                    <div class="preview-box">
                        <img id="faviconPreview" width="32" height="32">
                        <span>32×32</span>
                    </div>
                    <div class="preview-box">
                        <img id="faviconPreview16" width="16" height="16">
                        <span>16×16</span>
                    </div>
                    <div class="preview-box">
                        <div id="svgPreview" style="width: 80px; height: 80px; overflow: hidden;"></div>
                        <span>SVG</span>
                    </div>
                </div>
                <div class="download-links">
                    <a class="download-link" id="exportAppleIcon">Download apple-touch-icon.png</a>
                    <a class="download-link" id="exportFavicon">Download favicon.ico</a>
                    <a class="download-link" id="exportSVG">Download icon.svg</a>
                    <a class="download-link" id="exportJSON">Save as JSON</a>
                </div>
            </div>

            <!-- Canvas -->
            <div class="canvas-container">
                <canvas id="mainCanvas" width="384" height="384"></canvas>
            </div>

            <!-- Layers Panel -->
            <div class="layers-panel">
                <h2>Layers</h2>
                <div class="shape-list" id="shapeList"></div>
                <div class="layer-actions">
                    <button id="addShape">+ Add</button>
                    <button id="clearAll">Clear</button>
                </div>
            </div>

            <!-- Demos Panel -->
            <div class="demos-panel">
                <h2>Demos</h2>
                <div class="demo-list" id="demoList"></div>
            </div>
        </div>

        <!-- Controls Grid -->
        <div class="controls-grid">
            <!-- Colors Panel -->
            <div class="control-panel">
                <h2>Colors</h2>
                <div class="color-palette" id="colorPalette"></div>
                <div class="input-row">
                    <label>Fill</label>
                    <div class="fill-control">
                        <div class="no-fill-indicator" id="noFillBtn" title="No Fill"></div>
                        <input type="color" id="fillColorPicker">
                        <input type="text" id="customColor" placeholder="#ff5733">
                    </div>
                </div>
                <div class="input-row">
                    <label>Opacity</label>
                    <div class="range-container">
                        <input type="range" id="opacity" min="0" max="1" step="0.01" value="1">
                        <span class="range-value" id="opacityValue">1.00</span>
                    </div>
                </div>
                <div class="input-row">
                    <label>Stroke</label>
                    <select id="strokeWidth">
                        <option value="0">None</option>
                        <option value="1">1px</option>
                        <option value="2">2px</option>
                        <option value="3">3px</option>
                        <option value="4" selected>4px</option>
                        <option value="6">6px</option>
                        <option value="8">8px</option>
                        <option value="10">10px</option>
                        <option value="15">15px</option>
                        <option value="20">20px</option>
                    </select>
                </div>
                <div class="input-row" id="strokeColorRow">
                    <label>Stroke Color</label>
                    <div class="color-input-group">
                        <div class="no-fill-indicator" id="noStrokeBtn" title="No Stroke"></div>
                        <input type="color" id="strokeColorPicker" value="#000000">
                        <input type="text" id="strokeColor" placeholder="#000000" value="#000000">
                    </div>
                </div>
            </div>

            <!-- Shape Parameters Panel -->
            <div class="control-panel">
                <fieldset>
                    <legend>Shape Parameters</legend>
                    <div class="input-row">
                        <label>Preset</label>
                        <select id="presetSelect">
                            <option value="">Custom</option>
                            <option value="circle">Perfect Circle</option>
                            <option value="square">Rounded Square</option>
                            <option value="squircle">Icon Squircle</option>
                            <option value="star4">4-Pointed Star</option>
                            <option value="star5">5-Pointed Star</option>
                            <option value="star8">8-Pointed Star</option>
                            <option value="flower">Flower Shape</option>
                            <option value="gear">Gear/Cog</option>
                            <option value="diamond">Diamond</option>
                            <option value="cross">Cross/Plus</option>
                        </select>
                    </div>
                    <div class="input-row">
                        <label>m (symmetry)</label>
                        <input type="number" id="paramM" min="0" max="20" step="0.1" value="5">
                    </div>
                    <div class="param-grid-3">
                        <div class="input-row">
                            <label>n1</label>
                            <input type="number" id="paramN1" min="0.1" max="11" step="0.1" value="0.5">
                        </div>
                        <div class="input-row">
                            <label>n2</label>
                            <input type="number" id="paramN2" min="0.1" max="11" step="0.1" value="0.5">
                        </div>
                        <div class="input-row">
                            <label>n3</label>
                            <input type="number" id="paramN3" min="0.1" max="11" step="0.1" value="0.5">
                        </div>
                    </div>
                    <div class="param-grid">
                        <div class="input-row">
                            <label>a</label>
                            <input type="number" id="paramA" min="0.1" max="5" step="0.1" value="1">
                        </div>
                        <div class="input-row">
                            <label>b</label>
                            <input type="number" id="paramB" min="0.1" max="5" step="0.1" value="1">
                        </div>
                    </div>
                </fieldset>
            </div>

            <!-- Transform Panel -->
            <div class="control-panel">
                <h2>Transform</h2>
                <div class="input-row">
                    <label>Size</label>
                    <div class="range-container">
                        <input type="range" id="size" min="10" max="300" value="150">
                        <span class="range-value" id="sizeValue">150</span>
                    </div>
                </div>
                <div class="input-row">
                    <label>Rotation</label>
                    <div class="range-container">
                        <input type="range" id="rotation" min="0" max="360" value="0">
                        <input type="number" id="rotationValue" min="0" max="360" step="1" value="0" style="width: 60px;">
                    </div>
                </div>
                <div class="input-row">
                    <label>Position</label>
                    <div class="position-inputs">
                        <input type="number" id="posX" min="0" max="384" value="192" placeholder="X">
                        <input type="number" id="posY" min="0" max="384" value="192" placeholder="Y">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Modern icon color palette
        const defaultPalette = [
            '#FF6B6B', '#FF8E53', '#FFA64D', '#FFD93D', '#6BCF7F', '#4ECDC4',
            '#45B7D1', '#4D96FF', '#6C5CE7', '#A78BFA', '#F472B6', '#FB7185',
            '#EF4444', '#F97316', '#F59E0B', '#EAB308', '#22C55E', '#14B8A6',
            '#06B6D4', '#3B82F6', '#6366F1', '#8B5CF6', '#EC4899', '#F43F5E',
            '#DC2626', '#EA580C', '#D97706', '#CA8A04', '#16A34A', '#0D9488',
            '#0891B2', '#2563EB', '#4F46E5', '#7C3AED', '#DB2777', '#E11D48',
            '#000000', '#374151', '#6B7280', '#9CA3AF', '#D1D5DB', '#FFFFFF'
        ];

        // Preset configurations
        const presets = {
            circle: { m: 4, n1: 2, n2: 2, n3: 2, a: 1, b: 1 },
            square: { m: 4, n1: 4, n2: 4, n3: 4, a: 1, b: 1 },
            squircle: { m: 4, n1: 11, n2: 11, n3: 11, a: 1, b: 1, radius: 188 },
            star4: { m: 4, n1: 0.5, n2: 0.5, n3: 0.5, a: 1, b: 1 },
            star5: { m: 5, n1: 0.5, n2: 0.5, n3: 0.5, a: 1, b: 1 },
            star8: { m: 8, n1: 0.5, n2: 0.5, n3: 0.5, a: 1, b: 1 },
            flower: { m: 6, n1: 1, n2: 4, n3: 4, a: 1, b: 1 },
            gear: { m: 8, n1: 10, n2: 10, n3: 10, a: 1, b: 1 },
            diamond: { m: 4, n1: 1, n2: 1, n3: 1, a: 1, b: 1 },
            cross: { m: 4, n1: 100, n2: 100, n3: 100, a: 1, b: 1 }
        };

        // Helper function to lighten a color
        function lightenColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // Demo configurations
        const demos = {
            descendingStar: {
                name: "Descending Star",
                shapes: (function() {
                    const shapes = [];
                    const colors = ['#FF6B6B', '#FF8E53', '#FFA64D', '#FFD93D', '#6BCF7F', '#4ECDC4',
                                  '#45B7D1', '#4D96FF', '#6C5CE7', '#A78BFA', '#F472B6', '#FB7185',
                                  '#EF4444', '#F97316', '#F59E0B'];
                    for (let i = 0; i < 15; i++) {
                        const points = 18 - i;
                        const size = 160 - (i * 8);
                        const rotation = (i * 8) * Math.PI / 180;
                        const opacity = 0.9 - (i * 0.03);
                        const baseColor = colors[i % colors.length];
                        const lightColor = lightenColor(baseColor, i * 3);

                        const hexToRgba = (hex, alpha) => {
                            const r = parseInt(hex.slice(1, 3), 16);
                            const g = parseInt(hex.slice(3, 5), 16);
                            const b = parseInt(hex.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        };

                        shapes.push({
                            cx: 192,
                            cy: 192,
                            radius: size,
                            rotation: rotation,
                            m: points,
                            n1: 0.5,
                            n2: 0.5,
                            n3: 0.5,
                            a: 1,
                            b: 1,
                            fillColor: hexToRgba(lightColor, opacity),
                            strokeColor: lightenColor(baseColor, i * 2),
                            strokeWidth: 2
                        });
                    }
                    return shapes;
                })()
            },
            bloomingFlower: {
                name: "Blooming Flower",
                shapes: [
                    {
                        cx: 192,
                        cy: 192,
                        radius: 94,
                        rotation: 0.3316125578789226,
                        m: 6,
                        n1: 1,
                        n2: 4,
                        n3: 4,
                        a: 1,
                        b: 1,
                        fillColor: "rgba(244, 114, 182, 0.5)",
                        strokeColor: "#F472B6",
                        strokeWidth: 1
                    },
                    {
                        cx: 192,
                        cy: 192,
                        radius: 94,
                        rotation: 0.6632251157578452,
                        m: 4,
                        n1: 1,
                        n2: 4,
                        n3: 4,
                        a: 1,
                        b: 1,
                        fillColor: "rgba(236, 72, 153, 0.56)",
                        strokeColor: "#EC4899",
                        strokeWidth: 1
                    },
                    {
                        cx: 192,
                        cy: 192,
                        radius: 90,
                        rotation: 1.413716694115407,
                        m: 5,
                        n1: 1,
                        n2: 4,
                        n3: 4,
                        a: 1,
                        b: 1,
                        fillColor: "rgba(219, 39, 119, 0.62)",
                        strokeColor: "#DB2777",
                        strokeWidth: 1
                    },
                    {
                        cx: 192,
                        cy: 192,
                        radius: 90,
                        rotation: 2.199114857512855,
                        m: 6,
                        n1: 1,
                        n2: 4,
                        n3: 4,
                        a: 1,
                        b: 1,
                        fillColor: "rgba(190, 24, 93, 0.68)",
                        strokeColor: "#BE185D",
                        strokeWidth: 1
                    },
                    {
                        cx: 192,
                        cy: 192,
                        radius: 72,
                        rotation: 0.715584993317675,
                        m: 15,
                        n1: 1,
                        n2: 4,
                        n3: 4,
                        a: 1,
                        b: 1,
                        fillColor: "rgba(159, 18, 57, 0.74)",
                        strokeColor: "#9F1239",
                        strokeWidth: 1
                    },
                    {
                        cx: 192,
                        cy: 192,
                        radius: 94,
                        rotation: 0.8552113334772214,
                        m: 8,
                        n1: 1,
                        n2: 4,
                        n3: 4,
                        a: 1,
                        b: 1,
                        fillColor: "rgba(136, 19, 55, 0.8)",
                        strokeColor: "#881337",
                        strokeWidth: 1
                    },
                    {
                        cx: 192,
                        cy: 192,
                        radius: 67,
                        rotation: 1.8151424220741028,
                        m: 9,
                        n1: 1,
                        n2: 4,
                        n3: 4,
                        a: 1,
                        b: 1,
                        fillColor: "rgba(112, 26, 71, 0.86)",
                        strokeColor: "#701A47",
                        strokeWidth: 1
                    },
                    {
                        cx: 192,
                        cy: 192,
                        radius: 67,
                        rotation: 3.6477381366681487,
                        m: 9,
                        n1: 1,
                        n2: 4,
                        n3: 4,
                        a: 1,
                        b: 1,
                        fillColor: "rgba(93, 26, 87, 0.82)",
                        strokeColor: "#5D1A57",
                        strokeWidth: 1
                    },
                    {
                        cx: 192,
                        cy: 192,
                        radius: 18,
                        rotation: 1.8325957145940461,
                        m: 4,
                        n1: 2,
                        n2: 2,
                        n3: 2,
                        a: 1,
                        b: 1,
                        fillColor: "rgba(234, 179, 8, 0.82)",
                        strokeColor: "#a96800",
                        strokeWidth: 4
                    },
                    {
                        cx: 192,
                        cy: 192,
                        radius: 10,
                        rotation: 0.3316125578789226,
                        m: 4,
                        n1: 2,
                        n2: 2,
                        n3: 2,
                        a: 1,
                        b: 1,
                        fillColor: "rgba(255, 217, 61, 0.5)",
                        strokeColor: "#F472B6",
                        strokeWidth: 0
                    }
                ]
            },
            clockworkGears: {
                name: "Clockwork Gears",
                shapes: (function() {
                    const shapes = [];
                    const gearConfigs = [
                        { teeth: 12, size: 140, color: '#6B7280', rotation: 0 },
                        { teeth: 10, size: 110, color: '#9CA3AF', rotation: 18 },
                        { teeth: 8, size: 85, color: '#D1D5DB', rotation: 22.5 },
                        { teeth: 6, size: 60, color: '#E5E7EB', rotation: 30 },
                    ];

                    gearConfigs.forEach((config, i) => {
                        const hexToRgba = (hex, alpha) => {
                            const r = parseInt(hex.slice(1, 3), 16);
                            const g = parseInt(hex.slice(3, 5), 16);
                            const b = parseInt(hex.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        };

                        shapes.push({
                            cx: 192,
                            cy: 192,
                            radius: config.size,
                            rotation: config.rotation * Math.PI / 180,
                            m: config.teeth,
                            n1: 10,
                            n2: 10,
                            n3: 10,
                            a: 1,
                            b: 1,
                            fillColor: hexToRgba(config.color, 0.7),
                            strokeColor: '#374151',
                            strokeWidth: 3
                        });
                    });

                    return shapes;
                })()
            },
            rainbowBurst: {
                name: "Rainbow Burst",
                shapes: (function() {
                    const shapes = [];
                    const colors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];

                    colors.forEach((color, i) => {
                        const size = 150 - (i * 15);
                        const rotation = (i * 25) * Math.PI / 180;
                        const opacity = 0.6;

                        const hexToRgba = (hex, alpha) => {
                            const r = parseInt(hex.slice(1, 3), 16);
                            const g = parseInt(hex.slice(3, 5), 16);
                            const b = parseInt(hex.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        };

                        shapes.push({
                            cx: 192,
                            cy: 192,
                            radius: size,
                            rotation: rotation,
                            m: 12,
                            n1: 0.5,
                            n2: 0.5,
                            n3: 0.5,
                            a: 1,
                            b: 1,
                            fillColor: hexToRgba(color, opacity),
                            strokeColor: color,
                            strokeWidth: 2
                        });
                    });

                    return shapes;
                })()
            },
            geometricMandala: {
                name: "Geometric Mandala",
                shapes: (function() {
                    const shapes = [];
                    const layers = [
                        { m: 8, n1: 0.5, n2: 0.5, n3: 0.5, size: 150, color: '#6366F1', rotation: 0 },
                        { m: 8, n1: 2, n2: 2, n3: 2, size: 120, color: '#8B5CF6', rotation: 22.5 },
                        { m: 8, n1: 4, n2: 4, n3: 4, size: 90, color: '#A78BFA', rotation: 0 },
                        { m: 12, n1: 1, n2: 4, n3: 4, size: 65, color: '#C4B5FD', rotation: 15 },
                        { m: 4, n1: 2, n2: 5, n3: 5, size: 40, color: '#DDD6FE', rotation: 0 },
                    ];

                    layers.forEach((layer, i) => {
                        const hexToRgba = (hex, alpha) => {
                            const r = parseInt(hex.slice(1, 3), 16);
                            const g = parseInt(hex.slice(3, 5), 16);
                            const b = parseInt(hex.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        };

                        shapes.push({
                            cx: 192,
                            cy: 192,
                            radius: layer.size,
                            rotation: layer.rotation * Math.PI / 180,
                            m: layer.m,
                            n1: layer.n1,
                            n2: layer.n2,
                            n3: layer.n3,
                            a: 1,
                            b: 1,
                            fillColor: hexToRgba(layer.color, 0.7),
                            strokeColor: layer.color,
                            strokeWidth: 2
                        });
                    });

                    return shapes;
                })()
            },
            nestedSquares: {
                name: "Nested Squares",
                shapes: (function() {
                    const shapes = [];
                    const startRadius = 188;
                    const minRadius = 25;
                    const scaleFactor = 167 / 188; // Optimal nesting ratio (~0.888)
                    const rotationStep = 80 * Math.PI / 180; // 80 degrees in radians

                    // Calculate how many iterations we need
                    let currentRadius = startRadius;
                    let currentRotation = 0;
                    let iteration = 0;

                    // Gradient from steel blue to light gray
                    const startColor = { r: 70, g: 130, b: 180 };  // Steel blue
                    const endColor = { r: 220, g: 220, b: 220 };   // Light gray

                    while (currentRadius >= minRadius) {
                        // Calculate total iterations for gradient
                        const totalIterations = Math.ceil(Math.log(minRadius / startRadius) / Math.log(scaleFactor));
                        const t = iteration / (totalIterations - 1); // Interpolation factor 0 to 1

                        // Interpolate color
                        const r = Math.round(startColor.r + (endColor.r - startColor.r) * t);
                        const g = Math.round(startColor.g + (endColor.g - startColor.g) * t);
                        const b = Math.round(startColor.b + (endColor.b - startColor.b) * t);
                        const color = `rgb(${r}, ${g}, ${b})`;

                        shapes.push({
                            cx: 192,
                            cy: 192,
                            radius: Math.round(currentRadius),
                            rotation: currentRotation % (2 * Math.PI), // Keep rotation in [0, 2π)
                            m: 4,
                            n1: 11,
                            n2: 11,
                            n3: 11,
                            a: 1,
                            b: 1,
                            fillColor: color,
                            strokeColor: '#000000',
                            strokeWidth: 2
                        });

                        currentRadius *= scaleFactor;
                        currentRotation += rotationStep;
                        iteration++;
                    }

                    return shapes;
                })()
            }
        };

        // Application state
        let shapes = [];
        let selectedShapeIndex = null;
        let currentColor = '#FF6B6B';
        let currentOpacity = 1;
        let currentStrokeColor = '#000000';
        let draggedItem = null;
        let isFillNone = false;  // Track if fill is set to "none"
        let isStrokeNone = false;  // Track if stroke is set to "none"

        // Canvas dragging state
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartCX = 0;
        let dragStartCY = 0;

        // Canvas setup
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // Initialize color palette
        function initColorPalette() {
            const palette = document.getElementById('colorPalette');
            defaultPalette.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.background = color;
                if (color === currentColor) {
                    swatch.classList.add('selected');
                }
                swatch.addEventListener('click', () => {
                    currentColor = color;
                    isFillNone = false;  // Disable "no fill" when color is selected
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');
                    document.getElementById('customColor').value = color;
                    document.getElementById('fillColorPicker').value = color.startsWith('#') ? color : '#FF6B6B';
                    updateFillUIState();
                    updateSelectedShape();
                });
                palette.appendChild(swatch);
            });
        }

        // Superformula calculation
        function superformulaR(theta, {m, n1, n2, n3, a = 1, b = 1}) {
            const t1 = Math.pow(Math.abs(Math.cos((m * theta) / 4) / a), n2);
            const t2 = Math.pow(Math.abs(Math.sin((m * theta) / 4) / b), n3);
            const denom = t1 + t2;
            return Math.pow(Math.max(denom, 1e-12), -1 / n1);
        }

        // Draw superformula shape
        function drawSuperformula(ctx, shape, scaleFactor = 1) {
            const {cx, cy, radius, rotation, m, n1, n2, n3, a, b, steps = 1500} = shape;

            ctx.beginPath();

            for (let i = 0; i <= steps; i++) {
                const theta = (i / steps) * 2 * Math.PI;
                const r = superformulaR(theta, {m, n1, n2, n3, a, b});
                const ang = theta + rotation;
                const x = (cx * scaleFactor) + (radius * scaleFactor * r * Math.cos(ang));
                const y = (cy * scaleFactor) + (radius * scaleFactor * r * Math.sin(ang));

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.closePath();
        }

        // Render a shape with its properties
        function renderShape(ctx, shape, scaleFactor = 1) {
            ctx.save();

            drawSuperformula(ctx, shape, scaleFactor);

            const hasFill = shape.fillColor && shape.fillColor !== 'none';
            const hasStroke = shape.strokeWidth > 0;

            if (hasFill) {
                ctx.fillStyle = shape.fillColor;
                ctx.fill();
            }

            if (hasStroke) {
                ctx.strokeStyle = shape.strokeColor;
                ctx.lineWidth = shape.strokeWidth * scaleFactor;
                ctx.stroke();
            }

            ctx.restore();
        }

        // Render all shapes to canvas
        function renderCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            shapes.forEach(shape => {
                renderShape(ctx, shape);
            });

            updateExportPreviews();
        }

        // Check if a point is inside a shape
        function isPointInShape(x, y, shape) {
            ctx.save();
            ctx.beginPath();
            drawSuperformula(ctx, shape, 1);
            const result = ctx.isPointInPath(x, y);
            ctx.restore();
            return result;
        }

        // Create shape object from current settings
        function createShapeFromSettings() {
            const opacity = parseFloat(document.getElementById('opacity').value);
            const hexToRgba = (hex, alpha) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            };

            // Handle fill color based on "no fill" state
            let fillColor;
            if (isFillNone) {
                fillColor = 'none';
            } else if (currentColor.startsWith('#') && currentColor.length === 7) {
                fillColor = hexToRgba(currentColor, opacity);
            } else if (currentColor.startsWith('rgb(')) {
                fillColor = currentColor.replace('rgb', 'rgba').replace(')', `, ${opacity})`);
            } else {
                fillColor = currentColor;
            }

            // Handle stroke based on "no stroke" state
            let strokeWidth;
            let strokeColor;
            if (isStrokeNone) {
                strokeWidth = 0;
                strokeColor = currentStrokeColor;
            } else {
                strokeWidth = parseFloat(document.getElementById('strokeWidth').value);
                strokeColor = document.getElementById('strokeColor').value || currentStrokeColor;
            }

            return {
                cx: parseFloat(document.getElementById('posX').value),
                cy: parseFloat(document.getElementById('posY').value),
                radius: parseFloat(document.getElementById('size').value),
                rotation: parseFloat(document.getElementById('rotation').value) * Math.PI / 180,
                m: parseFloat(document.getElementById('paramM').value),
                n1: parseFloat(document.getElementById('paramN1').value),
                n2: parseFloat(document.getElementById('paramN2').value),
                n3: parseFloat(document.getElementById('paramN3').value),
                a: parseFloat(document.getElementById('paramA').value),
                b: parseFloat(document.getElementById('paramB').value),
                fillColor: fillColor,
                strokeColor: strokeColor,
                strokeWidth: strokeWidth,
            };
        }

        // Add new shape
        function addShape() {
            const shape = createShapeFromSettings();
            shapes.push(shape);
            selectedShapeIndex = shapes.length - 1;
            updateShapeList();
            renderCanvas();
            // Ensure UI state is updated after adding shape
            updateFillUIState();
            updateStrokeUIState();
        }

        // Update selected shape with current settings
        function updateSelectedShape() {
            if (selectedShapeIndex !== null && shapes[selectedShapeIndex]) {
                shapes[selectedShapeIndex] = createShapeFromSettings();
                updateShapeList();
                renderCanvas();
            }
        }

        // Load shape into editor
        function loadShapeToEditor(shape) {
            document.getElementById('posX').value = shape.cx;
            document.getElementById('posY').value = shape.cy;
            document.getElementById('size').value = shape.radius;
            document.getElementById('sizeValue').textContent = shape.radius;

            const rotationDeg = shape.rotation * 180 / Math.PI;
            document.getElementById('rotation').value = rotationDeg;
            document.getElementById('rotationValue').value = Math.round(rotationDeg);

            document.getElementById('paramM').value = shape.m;
            document.getElementById('paramN1').value = shape.n1;
            document.getElementById('paramN2').value = shape.n2;
            document.getElementById('paramN3').value = shape.n3;
            document.getElementById('paramA').value = shape.a;
            document.getElementById('paramB').value = shape.b;

            // Load fill color and opacity
            if (shape.fillColor === 'none') {
                isFillNone = true;
                updateFillUIState();
            } else {
                isFillNone = false;
                const rgbaMatch = shape.fillColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                if (rgbaMatch) {
                    const r = parseInt(rgbaMatch[1]);
                    const g = parseInt(rgbaMatch[2]);
                    const b = parseInt(rgbaMatch[3]);
                    const opacity = rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1;

                    // Convert to hex
                    const hexColor = '#' + [r, g, b].map(x => {
                        const hex = x.toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    }).join('');

                    // Update global state
                    currentColor = hexColor;
                    currentOpacity = opacity;

                    // Update color inputs
                    document.getElementById('fillColorPicker').value = hexColor;
                    document.getElementById('customColor').value = hexColor;

                    // Update opacity input
                    document.getElementById('opacity').value = opacity;
                    document.getElementById('opacityValue').textContent = opacity.toFixed(2);

                    // Update color palette selection
                    document.querySelectorAll('.color-swatch').forEach(swatch => {
                        if (swatch.style.background === hexColor || swatch.style.background === `rgb(${r}, ${g}, ${b})`) {
                            swatch.classList.add('selected');
                        } else {
                            swatch.classList.remove('selected');
                        }
                    });
                } else if (shape.fillColor.startsWith('#')) {
                    // Handle hex colors directly
                    currentColor = shape.fillColor;
                    currentOpacity = 1;

                    // Update color inputs
                    document.getElementById('fillColorPicker').value = shape.fillColor;
                    document.getElementById('customColor').value = shape.fillColor;

                    // Update opacity input
                    document.getElementById('opacity').value = 1;
                    document.getElementById('opacityValue').textContent = '1.00';

                    // Update color palette selection
                    document.querySelectorAll('.color-swatch').forEach(swatch => {
                        swatch.classList.remove('selected');
                    });
                } else {
                    // Fallback: use the color as-is
                    currentColor = shape.fillColor;
                    currentOpacity = 1;

                    // Update opacity input
                    document.getElementById('opacity').value = 1;
                    document.getElementById('opacityValue').textContent = '1.00';
                }
                updateFillUIState();
            }

            // Load stroke width and color
            if (shape.strokeWidth === 0) {
                isStrokeNone = true;
                document.getElementById('strokeWidth').value = 4; // Set to a default value
            } else {
                isStrokeNone = false;
                document.getElementById('strokeWidth').value = shape.strokeWidth;
            }

            document.getElementById('strokeColor').value = shape.strokeColor;
            document.getElementById('strokeColorPicker').value = shape.strokeColor;
            currentStrokeColor = shape.strokeColor;

            updateStrokeUIState();
            updateStrokeColorVisibility();
        }

        // Update shape list UI
        function updateShapeList() {
            const list = document.getElementById('shapeList');
            list.innerHTML = '';

            shapes.forEach((shape, index) => {
                const item = document.createElement('div');
                item.className = 'shape-item';
                item.draggable = true;
                if (index === selectedShapeIndex) {
                    item.classList.add('selected');
                }

                const info = document.createElement('div');
                info.className = 'shape-item-info';

                const preview = document.createElement('div');
                preview.className = 'shape-item-preview';
                preview.style.background = shape.fillColor;

                const label = document.createElement('span');
                label.className = 'shape-item-label';
                label.textContent = `Shape ${index + 1}`;

                info.appendChild(preview);
                info.appendChild(label);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.textContent = '×';
                deleteBtn.title = 'Delete shape';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteShape(index);
                });

                item.appendChild(info);
                item.appendChild(deleteBtn);

                // Drag and drop handlers
                item.addEventListener('dragstart', (e) => {
                    draggedItem = index;
                    item.classList.add('dragging');
                });

                item.addEventListener('dragend', (e) => {
                    item.classList.remove('dragging');
                    draggedItem = null;
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });

                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggedItem !== null && draggedItem !== index) {
                        const temp = shapes[draggedItem];
                        shapes.splice(draggedItem, 1);
                        shapes.splice(index, 0, temp);

                        if (selectedShapeIndex === draggedItem) {
                            selectedShapeIndex = index;
                        } else if (selectedShapeIndex === index) {
                            selectedShapeIndex = draggedItem > index ? selectedShapeIndex + 1 : selectedShapeIndex - 1;
                        }

                        updateShapeList();
                        renderCanvas();
                    }
                });

                item.addEventListener('click', () => {
                    selectedShapeIndex = index;
                    loadShapeToEditor(shape);
                    updateShapeList();
                });

                list.appendChild(item);
            });
        }

        // Delete shape at index
        function deleteShape(index) {
            shapes.splice(index, 1);
            if (selectedShapeIndex === index) {
                selectedShapeIndex = shapes.length > 0 ? Math.max(0, index - 1) : null;
                if (selectedShapeIndex !== null && shapes[selectedShapeIndex]) {
                    loadShapeToEditor(shapes[selectedShapeIndex]);
                }
            } else if (selectedShapeIndex > index) {
                selectedShapeIndex--;
            }
            updateShapeList();
            renderCanvas();
        }

        // Clear all shapes
        function clearAll() {
            if (confirm('Clear all shapes?')) {
                shapes = [];
                selectedShapeIndex = null;
                updateShapeList();
                renderCanvas();
            }
        }

        // Load a demo
        function loadDemo(demoKey) {
            if (demos[demoKey]) {
                shapes = JSON.parse(JSON.stringify(demos[demoKey].shapes)); // Deep clone
                selectedShapeIndex = shapes.length > 0 ? shapes.length - 1 : null;
                if (selectedShapeIndex !== null) {
                    loadShapeToEditor(shapes[selectedShapeIndex]);
                }
                updateShapeList();
                renderCanvas();
            }
        }

        // Generate random demo
        function generateRandomDemo() {
            shapes = [];
            const layerCount = Math.floor(Math.random() * 6) + 3; // 3-8 layers

            for (let i = 0; i < layerCount; i++) {
                const m = Math.floor(Math.random() * 16) + 3; // 3-18 symmetry
                // Clip to tenths (one decimal place)
                const n1 = Math.round((Math.random() * 9 + 0.5) * 10) / 10; // 0.5-9.5
                const n2 = Math.round((Math.random() * 9 + 0.5) * 10) / 10;
                const n3 = Math.round((Math.random() * 9 + 0.5) * 10) / 10;
                const a = Math.round((Math.random() * 2 + 0.5) * 10) / 10; // 0.5-2.5
                const b = Math.round((Math.random() * 2 + 0.5) * 10) / 10;

                // Clip size to integers, mostly smaller to avoid offscreen edges
                // Weighted towards smaller sizes: 70% chance of 40-100, 30% chance of 100-140
                const sizeRange = Math.random() < 0.7 ? 60 : 40;
                const sizeBase = Math.random() < 0.7 ? 40 : 100;
                const size = Math.floor(Math.random() * sizeRange + sizeBase); // Mostly 40-100, rarely 100-140

                const rotation = Math.random() * 360 * Math.PI / 180;
                const opacity = Math.random() * 0.5 + 0.4; // 0.4-0.9

                // Random color from palette
                const color = defaultPalette[Math.floor(Math.random() * (defaultPalette.length - 6))]; // Exclude greys

                const hexToRgba = (hex, alpha) => {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                };

                shapes.push({
                    cx: 192,
                    cy: 192,
                    radius: size,
                    rotation: rotation,
                    m: m,
                    n1: n1,
                    n2: n2,
                    n3: n3,
                    a: a,
                    b: b,
                    fillColor: hexToRgba(color, opacity),
                    strokeColor: color,
                    strokeWidth: Math.random() > 0.5 ? Math.floor(Math.random() * 3) + 1 : 0
                });
            }

            selectedShapeIndex = shapes.length > 0 ? shapes.length - 1 : null;
            if (selectedShapeIndex !== null) {
                loadShapeToEditor(shapes[selectedShapeIndex]);
            }
            updateShapeList();
            renderCanvas();
        }

        // Initialize demo list
        function initDemoList() {
            const demoList = document.getElementById('demoList');

            // Add preset demos
            Object.keys(demos).forEach(key => {
                const demo = demos[key];
                const item = document.createElement('div');
                item.className = 'demo-item';
                item.textContent = demo.name;
                item.addEventListener('click', () => loadDemo(key));
                demoList.appendChild(item);
            });

            // Add random button
            const randomItem = document.createElement('div');
            randomItem.className = 'demo-item random';
            randomItem.textContent = 'Random';
            randomItem.addEventListener('click', generateRandomDemo);
            demoList.appendChild(randomItem);
        }

        // Update fill UI state based on isFillNone
        function updateFillUIState() {
            const noFillBtn = document.getElementById('noFillBtn');
            const fillColorPicker = document.getElementById('fillColorPicker');
            const customColorInput = document.getElementById('customColor');
            const opacitySlider = document.getElementById('opacity');
            const opacityValue = document.getElementById('opacityValue');

            if (isFillNone) {
                noFillBtn.classList.add('active');
                fillColorPicker.disabled = true;
                customColorInput.disabled = true;
                opacitySlider.disabled = true;
                fillColorPicker.style.opacity = '0.5';
                customColorInput.style.opacity = '0.5';
                opacitySlider.style.opacity = '0.5';
                opacityValue.style.opacity = '0.5';
            } else {
                noFillBtn.classList.remove('active');
                fillColorPicker.disabled = false;
                customColorInput.disabled = false;
                opacitySlider.disabled = false;
                fillColorPicker.style.opacity = '1';
                customColorInput.style.opacity = '1';
                opacitySlider.style.opacity = '1';
                opacityValue.style.opacity = '1';
            }
        }

        // Update stroke UI state based on isStrokeNone
        function updateStrokeUIState() {
            const noStrokeBtn = document.getElementById('noStrokeBtn');
            const strokeWidthSelect = document.getElementById('strokeWidth');
            const strokeColorInput = document.getElementById('strokeColor');
            const strokeColorPicker = document.getElementById('strokeColorPicker');

            if (isStrokeNone) {
                noStrokeBtn.classList.add('active');
                // Don't disable stroke width selector - allow user to change it to re-enable
                strokeColorInput.disabled = true;
                strokeColorPicker.disabled = true;
                strokeColorInput.style.opacity = '0.5';
                strokeColorPicker.style.opacity = '0.5';
            } else {
                noStrokeBtn.classList.remove('active');
                strokeColorInput.disabled = false;
                strokeColorPicker.disabled = false;
                strokeColorInput.style.opacity = '1';
                strokeColorPicker.style.opacity = '1';
            }
        }

        // Update stroke color field visibility
        function updateStrokeColorVisibility() {
            const strokeWidth = parseFloat(document.getElementById('strokeWidth').value);
            const strokeColorRow = document.getElementById('strokeColorRow');
            const strokeColorInput = document.getElementById('strokeColor');
            const strokeColorPicker = document.getElementById('strokeColorPicker');
            const isStrokeEnabled = strokeWidth > 0 && !isStrokeNone;

            // Disable/enable inputs instead of hiding
            strokeColorInput.disabled = !isStrokeEnabled;
            strokeColorPicker.disabled = !isStrokeEnabled;

            // Adjust opacity to indicate disabled state
            strokeColorRow.style.opacity = isStrokeEnabled ? '1' : '0.5';
            strokeColorRow.style.pointerEvents = isStrokeEnabled ? 'auto' : 'none';
        }

        // Apply preset
        function applyPreset(presetName) {
            if (presets[presetName]) {
                const preset = presets[presetName];
                document.getElementById('paramM').value = preset.m;
                document.getElementById('paramN1').value = preset.n1;
                document.getElementById('paramN2').value = preset.n2;
                document.getElementById('paramN3').value = preset.n3;
                document.getElementById('paramA').value = preset.a;
                document.getElementById('paramB').value = preset.b;

                // Apply radius if specified in preset
                if (preset.radius !== undefined) {
                    document.getElementById('size').value = preset.radius;
                    document.getElementById('sizeValue').textContent = preset.radius;
                }

                // If no layers exist, create one automatically
                if (shapes.length === 0) {
                    addShape();
                } else {
                    updateSelectedShape();
                }
            }
        }

        // Render to a specific size canvas
        function renderToCanvas(size) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = size;
            tempCanvas.height = size;
            const tempCtx = tempCanvas.getContext('2d');

            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, size, size);

            const scaleFactor = size / 384;

            shapes.forEach(shape => {
                renderShape(tempCtx, shape, scaleFactor);
            });

            return tempCanvas;
        }

        // Update export previews
        function updateExportPreviews() {
            const preview64 = renderToCanvas(64);
            const preview32 = renderToCanvas(32);
            const preview16 = renderToCanvas(16);

            document.getElementById('preview64').src = preview64.toDataURL('image/png');
            document.getElementById('faviconPreview').src = preview32.toDataURL('image/png');
            document.getElementById('faviconPreview16').src = preview16.toDataURL('image/png');

            // Update SVG preview
            const svgPreviewContainer = document.getElementById('svgPreview');
            const svgContent = generateSVG(80);
            svgPreviewContainer.innerHTML = svgContent;
        }

        // Export apple touch icon
        function exportAppleTouchIcon() {
            const iconCanvas = renderToCanvas(180);
            iconCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'apple-touch-icon.png';
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        // Create ICO file with multiple sizes
        function createIcoFile(sizes) {
            const images = sizes.map(size => {
                const canvas = renderToCanvas(size);
                return {
                    size: size,
                    canvas: canvas,
                    imageData: canvas.getContext('2d').getImageData(0, 0, size, size)
                };
            });

            let offset = 6 + (images.length * 16);
            const imageBuffers = images.map(img => createBMPData(img.imageData));

            const totalSize = offset + imageBuffers.reduce((sum, buf) => sum + buf.byteLength, 0);
            const buffer = new ArrayBuffer(totalSize);
            const view = new DataView(buffer);
            const uint8View = new Uint8Array(buffer);

            view.setUint16(0, 0, true);
            view.setUint16(2, 1, true);
            view.setUint16(4, images.length, true);

            let currentOffset = offset;
            images.forEach((img, i) => {
                const entryOffset = 6 + (i * 16);
                const imageSize = imageBuffers[i].byteLength;

                view.setUint8(entryOffset, img.size === 256 ? 0 : img.size);
                view.setUint8(entryOffset + 1, img.size === 256 ? 0 : img.size);
                view.setUint8(entryOffset + 2, 0);
                view.setUint8(entryOffset + 3, 0);
                view.setUint16(entryOffset + 4, 1, true);
                view.setUint16(entryOffset + 6, 32, true);
                view.setUint32(entryOffset + 8, imageSize, true);
                view.setUint32(entryOffset + 12, currentOffset, true);

                currentOffset += imageSize;
            });

            currentOffset = offset;
            imageBuffers.forEach(imgBuffer => {
                uint8View.set(new Uint8Array(imgBuffer), currentOffset);
                currentOffset += imgBuffer.byteLength;
            });

            return buffer;
        }

        // Create BMP data for ICO format
        function createBMPData(imageData) {
            if (!imageData || !imageData.width || !imageData.height) {
                return new ArrayBuffer(0);
            }

            const width = imageData.width;
            const height = imageData.height;
            const headerSize = 40;
            const imageSize = width * height * 4;

            const maskRowSize = Math.ceil(Math.ceil(width / 8) / 4) * 4;
            const maskSize = maskRowSize * height;
            const totalSize = headerSize + imageSize + maskSize;

            const buffer = new ArrayBuffer(totalSize);
            const view = new DataView(buffer);
            const uint8View = new Uint8Array(buffer);

            view.setUint32(0, headerSize, true);
            view.setInt32(4, width, true);
            view.setInt32(8, height * 2, true);
            view.setUint16(12, 1, true);
            view.setUint16(14, 32, true);
            view.setUint32(16, 0, true);
            view.setUint32(20, imageSize + maskSize, true);
            view.setInt32(24, 0, true);
            view.setInt32(28, 0, true);
            view.setUint32(32, 0, true);
            view.setUint32(36, 0, true);

            let offset = headerSize;
            for (let y = height - 1; y >= 0; y--) {
                for (let x = 0; x < width; x++) {
                    const srcOffset = (y * width + x) * 4;
                    uint8View[offset++] = imageData.data[srcOffset + 2];
                    uint8View[offset++] = imageData.data[srcOffset + 1];
                    uint8View[offset++] = imageData.data[srcOffset];
                    uint8View[offset++] = imageData.data[srcOffset + 3];
                }
            }

            for (let y = height - 1; y >= 0; y--) {
                for (let x = 0; x < maskRowSize; x++) {
                    uint8View[offset++] = 0;
                }
            }

            return buffer;
        }

        // Export favicon
        function exportFavicon() {
            const sizes = [16, 32, 48, 64, 128, 256];
            const icoData = createIcoFile(sizes);
            const blob = new Blob([icoData], { type: 'image/x-icon' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'favicon.ico';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Generate SVG path data for a shape
        function generateSVGPath(shape) {
            const {cx, cy, radius, rotation, m, n1, n2, n3, a, b} = shape;
            // Use fewer steps for SVG to reduce file size (still plenty smooth)
            const steps = 360;
            let pathData = '';

            for (let i = 0; i <= steps; i++) {
                const theta = (i / steps) * 2 * Math.PI;
                const r = superformulaR(theta, {m, n1, n2, n3, a, b});
                const ang = theta + rotation;
                const x = cx + (radius * r * Math.cos(ang));
                const y = cy + (radius * r * Math.sin(ang));

                if (i === 0) {
                    pathData += `M ${x.toFixed(2)} ${y.toFixed(2)}`;
                } else {
                    pathData += ` L ${x.toFixed(2)} ${y.toFixed(2)}`;
                }
            }

            pathData += ' Z'; // Close path
            return pathData;
        }

        // Generate complete SVG document
        function generateSVG(size = 384) {
            const svgParts = [];
            svgParts.push(`<?xml version="1.0" encoding="UTF-8"?>`);
            svgParts.push(`<svg width="${size}" height="${size}" viewBox="0 0 384 384" xmlns="http://www.w3.org/2000/svg">`);

            // White background
            svgParts.push(`  <rect width="384" height="384" fill="white"/>`);

            // Render each shape
            shapes.forEach((shape, index) => {
                const pathData = generateSVGPath(shape);
                const hasFill = shape.fillColor && shape.fillColor !== 'none';
                const hasStroke = shape.strokeWidth > 0;

                let fillAttr = hasFill ? `fill="${shape.fillColor}"` : 'fill="none"';
                let strokeAttr = hasStroke ? `stroke="${shape.strokeColor}" stroke-width="${shape.strokeWidth}"` : 'stroke="none"';

                svgParts.push(`  <path d="${pathData}" ${fillAttr} ${strokeAttr}/>`);
            });

            svgParts.push(`</svg>`);
            return svgParts.join('\n');
        }

        // Export as SVG
        function exportSVG() {
            const svgContent = generateSVG(384);
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'icon.svg';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Export as JSON
        function exportJSON() {
            const data = {
                version: "1.0",
                shapes: shapes
            };
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'icon-layers.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Import from JSON
        function importJSON(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.shapes && Array.isArray(data.shapes)) {
                        shapes = data.shapes;
                        selectedShapeIndex = null;
                        updateShapeList();
                        renderCanvas();
                        updateExportPreviews();
                    } else {
                        alert('Invalid JSON file format. Expected a "shapes" array.');
                    }
                } catch (error) {
                    alert('Error parsing JSON file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Event listeners
        document.getElementById('addShape').addEventListener('click', addShape);
        document.getElementById('clearAll').addEventListener('click', clearAll);
        document.getElementById('exportAppleIcon').addEventListener('click', exportAppleTouchIcon);
        document.getElementById('exportFavicon').addEventListener('click', exportFavicon);
        document.getElementById('exportSVG').addEventListener('click', exportSVG);
        document.getElementById('exportJSON').addEventListener('click', exportJSON);

        // No fill button
        document.getElementById('noFillBtn').addEventListener('click', () => {
            isFillNone = !isFillNone;
            updateFillUIState();
            updateSelectedShape();
        });

        // No stroke button
        document.getElementById('noStrokeBtn').addEventListener('click', () => {
            isStrokeNone = !isStrokeNone;
            updateStrokeUIState();
            updateStrokeColorVisibility();
            updateSelectedShape();
        });

        // Import JSON
        document.getElementById('importJSONBtn').addEventListener('click', () => {
            document.getElementById('importJSON').click();
        });
        document.getElementById('importJSON').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                importJSON(file);
            }
            e.target.value = ''; // Reset input so same file can be loaded again
        });

        // Preset selector
        document.getElementById('presetSelect').addEventListener('change', (e) => {
            applyPreset(e.target.value);
        });

        // Custom color input
        document.getElementById('customColor').addEventListener('input', (e) => {
            currentColor = e.target.value;
            isFillNone = false;  // Disable "no fill" when color is changed
            document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
            if (e.target.value.startsWith('#')) {
                document.getElementById('fillColorPicker').value = e.target.value;
            }
            updateFillUIState();
            updateSelectedShape();
        });

        document.getElementById('fillColorPicker').addEventListener('input', (e) => {
            currentColor = e.target.value;
            isFillNone = false;  // Disable "no fill" when color is changed
            document.getElementById('customColor').value = currentColor;
            document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
            updateFillUIState();
            updateSelectedShape();
        });

        // Stroke color inputs
        document.getElementById('strokeColor').addEventListener('input', (e) => {
            currentStrokeColor = e.target.value;
            if (e.target.value.startsWith('#')) {
                document.getElementById('strokeColorPicker').value = e.target.value;
            }
            // Don't change isStrokeNone state, just update the color
            updateSelectedShape();
        });

        document.getElementById('strokeColorPicker').addEventListener('input', (e) => {
            currentStrokeColor = e.target.value;
            document.getElementById('strokeColor').value = e.target.value;
            // Don't change isStrokeNone state, just update the color
            updateSelectedShape();
        });

        // Stroke width
        document.getElementById('strokeWidth').addEventListener('change', (e) => {
            if (parseFloat(e.target.value) > 0) {
                isStrokeNone = false;  // Disable "no stroke" when width > 0
                updateStrokeUIState();
            }
            updateStrokeColorVisibility();
            updateSelectedShape();
        });

        // Opacity slider
        document.getElementById('opacity').addEventListener('input', (e) => {
            currentOpacity = parseFloat(e.target.value);
            document.getElementById('opacityValue').textContent = currentOpacity.toFixed(2);
            // Don't change isFillNone state, opacity is separate
            updateSelectedShape();
        });

        // Size and rotation sliders
        document.getElementById('size').addEventListener('input', (e) => {
            document.getElementById('sizeValue').textContent = e.target.value;
            updateSelectedShape();
        });

        document.getElementById('rotation').addEventListener('input', (e) => {
            document.getElementById('rotationValue').value = e.target.value;
            updateSelectedShape();
        });

        // Rotation value input - sync with slider
        document.getElementById('rotationValue').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            if (!isNaN(value)) {
                // Clamp value between 0 and 360
                const clampedValue = Math.max(0, Math.min(360, value));
                document.getElementById('rotation').value = clampedValue;
                updateSelectedShape();
            }
        });

        // All number inputs update on change
        ['paramM', 'paramN1', 'paramN2', 'paramN3', 'paramA', 'paramB',
         'posX', 'posY'].forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                document.getElementById('presetSelect').value = '';
                updateSelectedShape();
            });
        });

        // Canvas mouse event handlers for dragging shapes
        canvas.addEventListener('mousedown', (e) => {
            if (selectedShapeIndex === null || !shapes[selectedShapeIndex]) {
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicking on the selected shape
            if (isPointInShape(x, y, shapes[selectedShapeIndex])) {
                isDragging = true;
                dragStartX = x;
                dragStartY = y;
                dragStartCX = shapes[selectedShapeIndex].cx;
                dragStartCY = shapes[selectedShapeIndex].cy;
                canvas.style.cursor = 'move';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (isDragging && selectedShapeIndex !== null) {
                // Calculate the movement delta
                const deltaX = x - dragStartX;
                const deltaY = y - dragStartY;

                // Update position
                const newCX = dragStartCX + deltaX;
                const newCY = dragStartCY + deltaY;

                // Update the input fields
                document.getElementById('posX').value = Math.round(newCX);
                document.getElementById('posY').value = Math.round(newCY);

                // Update the shape
                updateSelectedShape();
            } else if (selectedShapeIndex !== null && shapes[selectedShapeIndex]) {
                // Update cursor when hovering over selected shape
                if (isPointInShape(x, y, shapes[selectedShapeIndex])) {
                    canvas.style.cursor = 'move';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'crosshair';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'crosshair';
        });

        // Arrow key controls for precise positioning
        document.addEventListener('keydown', (e) => {
            // Only handle arrow keys when there's a selected shape
            if (selectedShapeIndex === null || !shapes[selectedShapeIndex]) {
                return;
            }

            // Check if arrow keys are pressed
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault(); // Prevent page scrolling

                // Get current position
                const posXInput = document.getElementById('posX');
                const posYInput = document.getElementById('posY');
                let currentX = parseFloat(posXInput.value) || 0;
                let currentY = parseFloat(posYInput.value) || 0;

                // Determine step size (10 pixels with Shift, 1 pixel otherwise)
                const step = e.shiftKey ? 10 : 1;

                // Update position based on arrow key
                switch (e.key) {
                    case 'ArrowUp':
                        currentY -= step;
                        break;
                    case 'ArrowDown':
                        currentY += step;
                        break;
                    case 'ArrowLeft':
                        currentX -= step;
                        break;
                    case 'ArrowRight':
                        currentX += step;
                        break;
                }

                // Update the input fields
                posXInput.value = Math.round(currentX);
                posYInput.value = Math.round(currentY);

                // Update the shape
                updateSelectedShape();
            }
        });

        // Initialize
        initColorPalette();
        initDemoList();
        updateFillUIState();
        updateStrokeUIState();
        updateStrokeColorVisibility();
        renderCanvas();
    </script>
</body>
</html>
