<!doctype html>
<meta charset="utf-8">
<title>Rosette Spinner — 8 lobes in 3 turns</title>
<style>
  :root { color-scheme: dark; }
  html,body{height:100%;margin:0;background:#0f1115;color:#d7d7d7;font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:grid;grid-template-columns:1fr 280px;gap:16px;align-items:start;padding:16px}
  canvas{width:100%;height:100%;background:conic-gradient(from 0turn,#0b0d10,#0f1115 40%,#0f1115)}
  .panel{display:flex;flex-direction:column;gap:10px}
  button{padding:10px 14px;border-radius:10px;border:0;background:#2a66ff;color:#fff;
         font-weight:600;cursor:pointer}
  button.secondary{background:#2b2f3a;color:#d7d7d7}
  label{display:flex;justify-content:space-between;gap:12px}
  input[type=range]{width:100%}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .note{opacity:.75}
</style>

<div class="wrap">
  <canvas id="cv" aria-label="Rosette"></canvas>

  <div class="panel">
    <button id="toggle">▶︎ Animate</button>
    <button id="reset" class="secondary">Reset view</button>

    <label>Stroke width: <span id="wlab" class="mono"></span></label>
    <input id="width" type="range" min="1" max="10" step="1" value="4">

    <label>Lobe depth (amplitude): <span id="alab" class="mono"></span></label>
    <input id="amp" type="range" min="0" max="0.45" step="0.01" value="0.25">

    <label>Spin period (s): <span id="slab" class="mono"></span></label>
    <input id="spin" type="range" min="1.5" max="8" step="0.1" value="3.5">

    <label>Pulse period (s): <span id="plab" class="mono"></span></label>
    <input id="pulse" type="range" min="1.0" max="8" step="0.1" value="2.8">

    <div class="mono note">
      θ₁ = 2πt;  r = 1 + A·cos(16πt);  θ₂ = 6πt<br>
      x = r·cos(θ₂),  y = r·sin(θ₂)
    </div>
  </div>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  // UI
  const toggleBtn = document.getElementById('toggle');
  const resetBtn  = document.getElementById('reset');
  const amp = document.getElementById('amp');
  const width = document.getElementById('width');
  const spin = document.getElementById('spin');
  const pulse = document.getElementById('pulse');
  const wlab = document.getElementById('wlab');
  const alab = document.getElementById('alab');
  const slab = document.getElementById('slab');
  const plab = document.getElementById('plab');

  // Easing helpers (all map [0,1] → [0,1])
  const EASE = {
    // smooth S-curve; derivative zero at ends
    inOutCubic: t => t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2,
    inOutSine:  t => 0.5 - 0.5*Math.cos(Math.PI*t),
    inOutQuad:  t => t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2,
    // elastic micro-overshoot feel
    backInOut:  t => {
      const c1 = 1.70158, c2 = c1*1.525;
      return t<0.5
        ? (Math.pow(2*t,2) * ((c2+1)*2*t - c2)) / 2
        : (Math.pow(2*t-2,2)*((c2+1)*(t*2-2)+c2)+2)/2;
    }
  };

  let anim = false;
  let t0 = 0; // animation start (ms)
  let spinPhase0 = 0; // preserve phase on pause

  function resize() {
    const dpi = devicePixelRatio || 1;
    const w = Math.min(innerWidth - 320, innerHeight) | 0;
    cv.style.width = cv.style.height = w + 'px';
    cv.width  = (w * dpi) | 0;
    cv.height = (w * dpi) | 0;
    draw(0);
  }
  addEventListener('resize', resize, {passive:true});

  function rosettePoint(t, A) {
    // t ∈ [0,1] for a full draw pass; use dense sampling outside.
    const r = 1 + A * Math.cos(16*Math.PI*t);
    const th = 6 * Math.PI * t;
    return { x: r * Math.cos(th), y: r * Math.sin(th) };
  }

  function draw(elapsedMs) {
    const W = cv.width, H = cv.height;
    const dpi = devicePixelRatio || 1;

    // Parameters
    const A = +amp.value;
    const stroke = (+width.value) * dpi;
    const spinT = +spin.value;   // seconds per full revolution (base)
    const pulseT = +pulse.value; // seconds per pulse cycle

    // Labels
    wlab.textContent = width.value + ' px';
    alab.textContent = A.toFixed(2);
    slab.textContent = spinT.toFixed(1);
    plab.textContent = pulseT.toFixed(1);

    // Time (seconds)
    const tSec = elapsedMs/1000;

    // Spin: modulate angular speed with an easing wave for organic feel
    // base linear spin plus small eased wobble
    const spinLinear = (2*Math.PI) * (tSec / spinT);
    const wobble = 0.25 * EASE.inOutSine((tSec % 1.5) / 1.5); // slow modulation
    const angle = spinPhase0 + spinLinear * (1 + 0.2*wobble);

    // Pulse: size oscillation with eased S-curve to avoid harsh edges
    const p = (tSec / pulseT) % 1;
    const pulseEase = EASE.inOutCubic(p);
    const scale = 0.82 + 0.10 * (0.5 + 0.5*Math.sin(2*Math.PI*pulseEase));

    // Clear & set transform
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);
    ctx.translate(W/2, H/2);
    const s = Math.min(W, H) * 0.42 * scale;
    ctx.rotate(angle);

    // Soft shadow
    ctx.save();
    ctx.filter = 'blur(6px)';
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = '#000';
    pathRosette(A, s, 2200);
    ctx.fill();
    ctx.restore();

    // Stroke
    ctx.lineWidth = stroke;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.strokeStyle = '#b8c7ff';
    ctx.fillStyle = '#24315c';

    pathRosette(A, s, 2600);
    ctx.fill();
    ctx.stroke();

    if (anim) requestAnimationFrame(loop);
  }

  function pathRosette(A, s, N) {
    // Build a closed path with N samples
    const ctx = cv.getContext('2d');
    ctx.beginPath();
    for (let i = 0; i <= N; i++) {
      const t = i / N;
      const {x, y} = rosettePoint(t, A);
      if (i === 0) ctx.moveTo(x*s, y*s);
      else ctx.lineTo(x*s, y*s);
    }
    ctx.closePath();
  }

  function loop(now) {
    if (!t0) t0 = now;
    draw(now - t0);
  }

  toggleBtn.addEventListener('click', () => {
    anim = !anim;
    toggleBtn.textContent = anim ? '⏸ Pause' : '▶︎ Animate';
    if (anim) { t0 = 0; requestAnimationFrame(loop); }
    else {
      // capture current spin phase so resuming is seamless
      // approximate using current transform angle: not available; instead freeze angle by carrying spinPhase0
      // Here we let spinPhase0 accumulate implicitly by resetting t0 to zero.
      spinPhase0 = spinPhase0 + 0; // placeholder for clarity
    }
  });

  resetBtn.addEventListener('click', () => {
    amp.value = 0.25;
    width.value = 4;
    spin.value = 3.5;
    pulse.value = 2.8;
    draw(0);
  });

  // Redraw on control changes when not animating
  for (const el of [amp,width,spin,pulse]) {
    el.addEventListener('input', () => { if (!anim) draw(0); }, {passive:true});
  }

  resize(); // initial render
})();
</script>